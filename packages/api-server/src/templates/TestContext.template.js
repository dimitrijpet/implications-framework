// Auto-generated by Implications Framework
// Location: tests/ai-testing/utils/TestContext.js

class TestContext {
  /**
   * Fields that exist in memory but NEVER persist to JSON
   * These are session-only states that reset when the session ends
   * 
   * Loaded from ai-testing.config.js or uses defaults:
   * - 'logged_in' strips dancer.logged_in, club.logged_in, manager.logged_in
   * - 'app_opened' strips dancer.app_opened, etc.
   */
  static _sessionOnlyFields = null;
  
  /**
   * Get session-only fields from config or defaults
   */
  static getSessionOnlyFields() {
    if (this._sessionOnlyFields) return this._sessionOnlyFields;
    
    const fs = require('fs');
    const path = require('path');
    
    // Try to load from config
    try {
      const configPath = path.join(process.cwd(), 'ai-testing.config.js');
      if (fs.existsSync(configPath)) {
        delete require.cache[require.resolve(configPath)];
        const config = require(configPath);
        if (config.sessionOnlyFields && Array.isArray(config.sessionOnlyFields)) {
          console.log('üìã Loaded sessionOnlyFields from ai-testing.config.js');
          this._sessionOnlyFields = config.sessionOnlyFields;
          return this._sessionOnlyFields;
        }
      }
    } catch (e) {
      // Config not found or invalid, use defaults
    }
    
    // Defaults
    this._sessionOnlyFields = ['logged_in', 'app_opened', 'session_ready'];
    return this._sessionOnlyFields;
  }
  
  /**
   * Strip session-only fields from nested objects
   * e.g., removes dancer.logged_in, club.logged_in, etc.
   */
  _stripSessionFieldsFromObject(obj, parentKey = '') {
    if (!obj || typeof obj !== 'object') return;
    
    const sessionFields = TestContext.getSessionOnlyFields();
    
    for (const key of Object.keys(obj)) {
      // Check if this key is a session-only field
      if (sessionFields.includes(key)) {
        console.log(`   üîí Stripped session field: ${parentKey ? parentKey + '.' : ''}${key}`);
        delete obj[key];
        continue;
      }
      
      // Recurse into nested objects (but not arrays or special objects)
      const value = obj[key];
      if (value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {
        // Skip internal fields
        if (key.startsWith('_')) continue;
        
        this._stripSessionFieldsFromObject(value, parentKey ? `${parentKey}.${key}` : key);
      }
    }
  }
  
  constructor(ImplicationClass, testData, actualFilePath) {
  this.ImplicationClass = ImplicationClass;
  this.data = testData;
  this.changeLog = [];
  this.actualFilePath = actualFilePath;
  this.inputPath = actualFilePath;  // ‚Üê ADD THIS LINE
    
    this.config = {
      device: testData.device || testData._config?.device || 'desktop',
      lang: testData.lang || testData._config?.lang || 'fr',
      carrier: testData.carrier || testData._config?.carrier || 'LCC',
      debugMode: testData.debugMode || testData._config?.debugMode || false,
      baseURL: testData._config?.baseURL,
      ...testData._config
    };
    
    this.wrappers = {};
    this.bookingData = {};
    this.flightData = {};
    
    this.runtime = {
      price: null,
      indexStart: 0,
      orderId: null
    };
  }
  
  static getDeltaPath(inputPath) {
    if (inputPath.includes('-master.')) {
      return inputPath.replace('-master.', '-current.');
    }
    if (inputPath.includes('-current.')) {
      return inputPath;
    }
    return inputPath.replace('.json', '-current.json');
  }
  
static load(ImplicationClass, testDataPath) {
  const fs = require('fs');
  const path = require('path');
  
  let actualPath = testDataPath;
  let isMasterFile = testDataPath.includes('-master.');
  
  if (!isMasterFile) {
    const baseName = path.basename(testDataPath, '.json');
    const dirName = path.dirname(testDataPath);
    const currentPath = path.join(dirName, `${baseName}-current.json`);
    
    if (fs.existsSync(currentPath)) {
      actualPath = currentPath;
      console.log(`   üìÇ Loading from delta file: ${path.basename(currentPath)}`);
    } else {
      console.log(`   üìÇ Loading from: ${path.basename(testDataPath)}`);
    }
  }
  
  const fileContents = fs.readFileSync(actualPath, 'utf8');
  const rawData = JSON.parse(fileContents);
  
  let data;
  let originalSnapshot; // ‚úÖ Capture the true original before any mutations
  
  if (rawData._changeLog !== undefined) {
    // Delta file format: { _original: {...}, _changeLog: [...] }
    const original = rawData._original || {};
    originalSnapshot = JSON.parse(JSON.stringify(original)); // ‚úÖ Deep clone of true original
    data = JSON.parse(JSON.stringify(original)); // Deep clone to work with
    
    if (rawData._changeLog.length > 0) {
      for (const change of rawData._changeLog) {
        // Apply each delta key, handling dot notation for nested fields
        for (const [key, value] of Object.entries(change.delta)) {
          if (key.includes('.')) {
            // Dot notation - set nested value (e.g., "booking.status" ‚Üí data.booking.status)
            TestContext.setNestedValue(data, key, value);
          } else {
            data[key] = value;
          }
        }
      }
      console.log(`   üìä Applied ${rawData._changeLog.length} changes from history`);
      
      // Log the actual entity status if applicable
      const entityStatus = data.booking?.status || data.status;
      console.log(`   üéØ Current state: ${entityStatus}`);
    } else {
      console.log(`   ‚ú® Fresh state loaded`);
    }
  } else {
    // Original file format: flat JSON - this IS the original
    data = JSON.parse(JSON.stringify(rawData)); // Deep clone
    originalSnapshot = JSON.parse(JSON.stringify(rawData)); // ‚úÖ Capture original
    console.log(`   ‚ú® Fresh state loaded`);
  }
  
  TestContext._transformDates(data);
  console.log('   ‚úÖ Date transformation complete');
  
  const meta = ImplicationClass.xstateConfig?.meta || ImplicationClass.meta;
  
  if (meta?.entity) {
    const entity = meta.entity;
    console.log(`   üîç Entity-scoped implication: ${entity}`);
    
    const entityData = data[entity] || {};
    const entityStatus = entityData.status || null;
    
    if (entityStatus) {
      console.log(`   ‚úÖ Found entity status: ${entity}.status = ${entityStatus}`);
      data._entityStatus = entityStatus;
      data._entity = entity;
    } else {
      console.log(`   ‚ö†Ô∏è  Entity ${entity} has no status field`);
    }
  }
  
  const ctx = new TestContext(ImplicationClass, data, testDataPath);
  ctx._originalSnapshot = originalSnapshot; // ‚úÖ Store the true original for save()
  ctx.actualFilePath = actualPath;
  
  return ctx;
}

  static _transformDates(obj) {
    const moment = require('moment');
    
    function transform(value, key = '', parentKey = '') {
      if (!value) return value;
      
      if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
        const momentObj = moment(value);
        console.log(`   üîÑ Transformed ${parentKey ? parentKey + '.' : ''}${key}: moment object`);
        return momentObj;
      }
      
      if (Array.isArray(value)) {
        return value.map((item, index) => transform(item, index, key));
      }
      
      if (typeof value === 'object' && value !== null) {
        const result = {};
        for (const [k, v] of Object.entries(value)) {
          result[k] = transform(v, k, parentKey ? `${parentKey}.${key}` : key);
        }
        return result;
      }
      
      return value;
    }
    
    for (const [key, value] of Object.entries(obj)) {
      obj[key] = transform(value, key);
    }
    
    return obj;
  }
  
save(testDataPath) {
  const fs = require('fs');
  const path = require('path');
  
  let savePath;
  
  if (testDataPath) {
    savePath = TestContext.getDeltaPath(testDataPath);
  } else if (this.inputPath) {
    savePath = TestContext.getDeltaPath(this.inputPath);
  } else {
    savePath = this.actualFilePath;
  }
  
  // ‚úÖ Use the original snapshot captured at load time (before any mutations)
  // This preserves ALL original fields like dancer.email
  const originalData = this._originalSnapshot 
    ? JSON.parse(JSON.stringify(this._originalSnapshot))
    : JSON.parse(JSON.stringify(this.data)); // Fallback if no snapshot
  
  this._stripSessionFieldsFromObject(originalData);
  
  const sessionFields = TestContext.getSessionOnlyFields();
  const cleanedChangeLog = this.changeLog.map(change => {
    const cleanedDelta = { ...change.delta };
    
    for (const key of Object.keys(cleanedDelta)) {
      const fieldName = key.split('.').pop();
      if (sessionFields.includes(fieldName)) {
        delete cleanedDelta[key];
        console.log(`   üîí Stripped session field from delta: ${key}`);
      }
    }
    
    return {
      ...change,
      delta: cleanedDelta
    };
  }).filter(change => Object.keys(change.delta).length > 0);
  
  const output = {
    _original: originalData,
    _changeLog: cleanedChangeLog
  };
  
  fs.writeFileSync(savePath, JSON.stringify(output, null, 2));
  
  const fileName = path.basename(savePath);
  const isMaster = savePath.includes('-master.');
  
  if (isMaster) {
    console.log(`   ‚ö†Ô∏è  WARNING: Saved to master file: ${fileName}`);
  } else {
    console.log(`   üíæ Saved to delta file: ${fileName}`);
  }
}
  
  getBooking(index) {
    if (!this.data.bookings || !this.data.bookings[index]) {
      throw new Error(`Booking at index ${index} not found`);
    }
    return this.data.bookings[index];
  }
  
  getBookingsByStatus(status) {
    if (!this.data.bookings) return [];
    return this.data.bookings.filter(b => b.status === status);
  }
  
  getBookingsByIndices(indices) {
    if (!this.data.bookings) return [];
    return indices.map(i => this.getBooking(i));
  }
  
  applyDelta(path, value) {
    if (path.includes('[')) {
      const match = path.match(/^(\w+)\[(\d+)\]\.?(.*)$/);
      if (match) {
        const [, arrayName, index, rest] = match;
        if (!this.data[arrayName]) this.data[arrayName] = [];
        if (!this.data[arrayName][index]) this.data[arrayName][index] = {};
        if (rest) {
          this.data[arrayName][index][rest] = value;
        } else {
          this.data[arrayName][index] = { ...this.data[arrayName][index], ...value };
        }
      }
    } else {
      this.data[path] = value;
    }
  }
  
  getFromArray(arrayName, index) {
    if (!this.data[arrayName]) {
      console.warn(`‚ö†Ô∏è  Array '${arrayName}' does not exist`);
      return null;
    }
    return this.data[arrayName][index] || null;
  }
  
  setInArray(arrayName, index, value) {
    if (!this.data[arrayName]) {
      this.data[arrayName] = [];
    }
    this.data[arrayName][index] = value;
  }
  
  pushToArray(arrayName, value) {
    if (!this.data[arrayName]) {
      this.data[arrayName] = [];
    }
    this.data[arrayName].push(value);
    return this.data[arrayName].length - 1;
  }
  
  removeFromArray(arrayName, index) {
    if (!this.data[arrayName]) {
      console.warn(`‚ö†Ô∏è  Array '${arrayName}' does not exist`);
      return;
    }
    this.data[arrayName].splice(index, 1);
  }

  static getNestedValue(obj, path) {
    if (!path.includes('.')) {
      return obj[path];
    }
    
    const parts = path.split('.');
    let current = obj;
    
    for (const part of parts) {
      if (!current || !current.hasOwnProperty(part)) {
        return undefined;
      }
      current = current[part];
    }
    
    return current;
  }
  
  static setNestedValue(obj, path, value) {
    if (!path.includes('.')) {
      obj[path] = value;
      return;
    }
    
    const parts = path.split('.');
    let current = obj;
    
    for (let i = 0; i < parts.length - 1; i++) {
      if (!current[parts[i]]) {
        current[parts[i]] = {};
      }
      current = current[parts[i]];
    }
    
    current[parts[parts.length - 1]] = value;
  }
  
async executeAndSave(label, testFile, deltaFn) {
  const { delta } = await deltaFn();
  
  for (const [key, value] of Object.entries(delta)) {
    if (key.includes('.')) {
      const parts = key.split('.');
      let obj = this.data;
      for (let i = 0; i < parts.length - 1; i++) {
        if (!obj[parts[i]]) obj[parts[i]] = {};
        obj = obj[parts[i]];
      }
      obj[parts[parts.length - 1]] = value;
    } else {
      this.data[key] = value;
    }
  }
  
  this.changeLog.push({
    label,
    testFile,
    delta,
    timestamp: new Date().toISOString()
  });
  
  // ‚úÖ AUTO-SAVE: Write to delta file immediately
  this.save();
  
  return this;
}

/**
 * Cleanup delta files after test run
 * @param {string} testDataPath - Original test data path
 * @param {object} options - Options
 * @param {boolean} options.passed - Whether test passed
 * @param {boolean} options.interactive - Whether to prompt user (default: true for failures)
 */
static async cleanup(testDataPath, options = {}) {
  // Skip cleanup during cross-platform prerequisite execution
  if (process.env.IS_PREREQUISITE_EXECUTION === 'true') {
    console.log('‚è≠Ô∏è  Skipping cleanup (prerequisite execution - preserving state for next test)');
    return;
  }
  const fs = require('fs');
  const path = require('path');
  
  const { passed = true, interactive = true } = options;
  const deltaPath = this.getDeltaPath(testDataPath);
  
  if (!fs.existsSync(deltaPath)) {
    return; // Nothing to clean
  }
  
  if (passed) {
    // Auto-delete on success
    fs.unlinkSync(deltaPath);
    console.log(`üßπ Auto-cleaned: ${path.basename(deltaPath)}`);
  } else if (interactive && process.stdout.isTTY) {
    // Prompt on failure (only in interactive terminal)
    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    return new Promise((resolve) => {
      rl.question(`\nüóëÔ∏è  Delete ${path.basename(deltaPath)}? [Y/n] `, (answer) => {
        rl.close();
        const shouldDelete = !answer || answer.toLowerCase() === 'y';
        if (shouldDelete) {
          fs.unlinkSync(deltaPath);
          console.log(`üßπ Deleted: ${path.basename(deltaPath)}`);
        } else {
          console.log(`üìÅ Kept: ${path.basename(deltaPath)}`);
        }
        resolve();
      });
    });
  } else {
    // Non-interactive failure - just log
    console.log(`\n‚ö†Ô∏è  Delta file preserved: ${deltaPath}`);
    console.log(`   To delete manually: rm "${deltaPath}"`);
  }
}  
}

module.exports = TestContext;
