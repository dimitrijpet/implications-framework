// packages/core/src/generators/UnitTestGenerator.js
// ES MODULE VERSION

import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const require = createRequire(import.meta.url);
// Dynamic import for TemplateEngine
let TemplateEngine;

/**
 * UnitTestGenerator - Generic Test Generation Framework
 * 
 * Generates UNIT test files from Implication class definitions.
 * Fully configurable and project-agnostic.
 * 
 * Features:
 * - Configuration-driven (reads ai-testing.config.js)
 * - No hardcoded project structure assumptions
 * - Configurable discovery with metadata override
 * - Support for section-based workflows
 * - Multi-state machine support
 * - Platform-agnostic (web, cms, mobile)
 */
class UnitTestGenerator {
  
  constructor(options = {}) {
    this.options = {
      templatePath: options.templatePath || path.join(__dirname, 'unit-test.hbs'),
      outputDir: options.outputDir || null,
      ...options
    };
  }

  /**
   * Load project configuration file
   * 
   * Searches for ai-testing.config.js in:
   * 1. Explicit path provided in options
   * 2. Current working directory
   * 3. Project root (found by looking for package.json)
   */
  _loadConfig() {
    let configPath = this.options.configPath;
    
    // If not provided, search for it
    if (!configPath) {
      const searchPaths = [
        path.join(process.cwd(), 'ai-testing.config.js'),
        path.join(this._findProjectRoot(), 'ai-testing.config.js')
      ];
      
      for (const searchPath of searchPaths) {
        if (fs.existsSync(searchPath)) {
          configPath = searchPath;
          break;
        }
      }
    }
    
    // Load config or use defaults
    if (configPath && fs.existsSync(configPath)) {
      console.log(`üìã Loading config: ${configPath}`);
      
      // Clear require cache to get fresh config
      delete require.cache[require.resolve(configPath)];
      
      return require(configPath);
    } else {
      console.warn('‚ö†Ô∏è  No ai-testing.config.js found, using defaults');
      return this._getDefaultConfig();
    }
  }
  
  /**
   * Get default configuration when no config file exists
   */
  _getDefaultConfig() {
    return {
      paths: {
        tests: 'tests',
        implications: 'tests/implications',
        utils: 'tests/utils',
        screenObjects: 'tests/screenObjects',
        sections: 'tests/screenObjects/sections',
        testData: 'test-data',
        credentials: 'test-data/credentials.json'
      },
      conventions: {
        sectionPattern: '{name}.section.js',
        screenPattern: '{name}.screen.js',
        defaultCredentialKey: 'default'
      },
      generator: {
        enableDiscovery: true,
        onMissingFile: 'error',  // error | warn | skip | template
        templateDir: null
      }
    };
  }
  
  /**
   * Generate UNIT test from Implication class
   * 
   * @param {string} implFilePath - Path to Implication file
   * @param {object} options - Generation options
   * @param {string} options.platform - Platform: 'web', 'cms', 'dancer', 'manager'
   * @param {string} options.state - Target state (for multi-state machines)
   * @param {boolean} options.preview - Return code without writing file
   * @returns {object} { code, fileName, filePath } or array of results for multi-state
   */
  async generate(implFilePath, options = {}) {
    const {
      platform = 'web',
      state = null,
      preview = false
    } = options;
    
    console.log('\nüéØ UnitTestGenerator.generate()');
    console.log(`   Implication: ${implFilePath}`);
    console.log(`   Platform: ${platform}`);
    if (state) console.log(`   State: ${state}`);
    
    // 1. Load Implication class
    const ImplClass = this._loadImplication(implFilePath);
    
    // 2. Detect if multi-state machine
    const isMultiState = this._isMultiStateMachine(ImplClass);
    
    if (isMultiState && !state) {
      // Generate for ALL states
      console.log(`   ‚ú® Multi-state machine detected`);
      return await this._generateMultiState(ImplClass, implFilePath, platform, preview);
    } else if (isMultiState && state) {
      // Generate for specific state
      console.log(`   ‚ú® Generating for state: ${state}`);
      return await this._generateSingleState(ImplClass, implFilePath, platform, state, preview);
    } else {
      // Single-state machine (original behavior)
      return await this._generateSingleState(ImplClass, implFilePath, platform, null, preview);
    }
  }
  
/**
   * Check if this is a multi-state machine
   */
  _isMultiStateMachine(ImplClass) {
    const xstateConfig = ImplClass.xstateConfig;
    
    // Multi-state has: initial + states
    // Single-state has: meta at root
    return !!(xstateConfig.initial && xstateConfig.states);
  }
  
  /**
   * Generate tests for all states in a multi-state machine
   */
  async _generateMultiState(ImplClass, implFilePath, platform, preview) {
    const states = Object.keys(ImplClass.xstateConfig.states);
    
    console.log(`   üìã Found ${states.length} states: ${states.join(', ')}`);
    console.log('');
    
    const results = [];
    
    for (const stateName of states) {
      const stateConfig = ImplClass.xstateConfig.states[stateName];
      
      // Skip states without setup (no test needed)
      if (!stateConfig.meta?.setup || stateConfig.meta.setup.length === 0) {
        console.log(`   ‚è≠Ô∏è  Skipping ${stateName} (no setup defined)`);
        continue;
      }
      
      console.log(`   üéØ Generating for state: ${stateName}`);
      
      const result = await this._generateSingleState(
        ImplClass, 
        implFilePath, 
        platform, 
        stateName, 
        preview
      );
      
      results.push(result);
      console.log('');
    }
    
    console.log(`   ‚úÖ Generated ${results.length} test(s)\n`);
    
    return results;
  }
  
  /**
   * Generate test for a single state
   */
  async _generateSingleState(ImplClass, implFilePath, platform, stateName, preview) {
    // Store implFilePath for smart path calculation
    this.implFilePath = implFilePath;
    
    // Load config (needed for path resolution)
    if (!this.config) {
      this.config = this._loadConfig();
    }
    
    // 2. Extract metadata
    const metadata = this._extractMetadata(ImplClass, platform, stateName);
    
    // 3. Build template context
    const context = this._buildContext(metadata, platform);
    
    // 4. Validate context
    this._validateContext(context);
    
    // 5. Render template - lazy load TemplateEngine with dynamic import
    if (!TemplateEngine) {
      const TemplateEngineModule = await import('./TemplateEngine.js');
      TemplateEngine = TemplateEngineModule.default || TemplateEngineModule;
    }
    
    // Get template directory from options
    const templatesDir = this.options.templatePath 
      ? path.dirname(this.options.templatePath)
      : path.join(__dirname, '../templates');
    
    const engine = new TemplateEngine({ templatesDir });
    const code = engine.render('unit-test.hbs', context);
    
    // 6. Generate file name
    const fileName = this._generateFileName(metadata, platform);
    
    // 7. Optionally write file
    let filePath = null;
    if (!preview && this.options.outputDir) {
      filePath = path.join(this.options.outputDir, fileName);
      fs.writeFileSync(filePath, code);
      console.log(`      ‚úÖ Written: ${filePath}`);
    } else {
      console.log(`      ‚úÖ Preview generated (${code.length} chars)`);
    }
    
    return {
      code,
      fileName,
      filePath,
      metadata,
      state: stateName
    };
  }
  
 /**
   * Load Implication class from file
   */
  _loadImplication(implFilePath) {
    if (!fs.existsSync(implFilePath)) {
      throw new Error(`Implication file not found: ${implFilePath}`);
    }
    
    console.log(`   üì• Loading implication from: ${implFilePath}`);
    
    try {
      // Clear require cache to get fresh version
      delete require.cache[require.resolve(implFilePath)];
      
      // Use require() for CommonJS files - preserves static properties!
      const ImplClass = require(implFilePath);
      
      if (!ImplClass) {
        throw new Error(`No export found in ${implFilePath}`);
      }
      
      console.log(`   üìã ImplClass name: ${ImplClass.name || 'Anonymous'}`);
      console.log(`   üìã ImplClass type: ${typeof ImplClass}`);
      
      // Check for xstateConfig on the class
      if (!ImplClass.xstateConfig) {
        const availableProps = Object.getOwnPropertyNames(ImplClass).filter(p => !p.startsWith('_'));
        throw new Error(
          `Invalid Implication: missing xstateConfig in ${implFilePath}\n` +
          `Available static properties: ${availableProps.join(', ') || 'none'}\n` +
          `Make sure the class has: static xstateConfig = { ... }`
        );
      }
      
      console.log(`   ‚úÖ Loaded with xstateConfig`);
      
      return ImplClass;
      
    } catch (error) {
      console.error(`   ‚ùå Failed to load implication:`);
      console.error(`      ${error.message}`);
      
      // If it's a syntax error in the guest file, give helpful message
      if (error.message.includes('assign is not defined')) {
        throw new Error(
          `The implication file is missing XState imports.\n` +
          `Add this at the top of ${path.basename(implFilePath)}:\n` +
          `const { assign } = require('xstate');`
        );
      }
      
      throw error;
    }
  }
  
  /**
   * Extract metadata from Implication class
   */
  _extractMetadata(ImplClass, platform, stateName = null) {
    const xstateConfig = ImplClass.xstateConfig;
    
    let meta, status, entry, transitions, previousStatus;
    
    if (stateName) {
      // Multi-state machine: extract from specific state
      const stateConfig = xstateConfig.states[stateName];
      
      if (!stateConfig) {
        throw new Error(`State "${stateName}" not found in xstateConfig`);
      }
      
      meta = stateConfig.meta || {};
      status = meta.status || stateName;
      entry = stateConfig.entry;
      transitions = stateConfig.on || {};
      
      // Find previous state by looking at ALL transitions
      previousStatus = this._findPreviousState(xstateConfig.states, stateName);
      
    } else {
      // Single-state machine: extract from root
      meta = xstateConfig.meta || {};
      status = meta.status;
      entry = xstateConfig.entry;
      transitions = xstateConfig.on || {};
      previousStatus = meta.requires?.previousStatus;
    }
    
    const metadata = {
      // Class info
      className: ImplClass.name,
      
      // Status info
      status: status,
      previousStatus: previousStatus || meta.requires?.previousStatus,
      
      // Fields
      requiredFields: meta.requiredFields || [],
      
      // Setup info
      setup: meta.setup || [],
      
      // Buttons
      triggerButton: meta.triggerButton,
      afterButton: meta.afterButton,
      previousButton: meta.previousButton,
      
      // Transitions
      transitions: transitions,
      
      // Entry actions (for delta)
      entry: entry,
      
      // Action details (if provided)
      actionDetails: meta.actionDetails,
      
      // Triggered by (multi-platform actions)
      triggeredBy: ImplClass.triggeredBy || [],
      
      // Mirrors on (for validation)
      mirrorsOn: ImplClass.mirrorsOn,
      
      // State name (for multi-state)
      stateName: stateName,
      
      // Section-based workflow info
      usesSection: meta.usesSection || false,
      sectionType: meta.sectionType,
      sectionClass: meta.sectionClass,
      sectionPath: meta.sectionPath,
      scenarios: meta.scenarios,
      requiresOptions: meta.requiresOptions || [],
      
      // Additional paths (explicit from metadata)
      loginScreenPath: meta.loginScreenPath,
      addPageScreenPath: meta.addPageScreenPath,
      credentialsPath: meta.credentialsPath,
      credentialKey: meta.credentialKey,
      locale: meta.locale || 'en'
    };
    
    // Filter setup for this platform
    metadata.platformSetup = metadata.setup.find(s => s.platform === platform);
    
    return metadata;
  }
  
  /**
   * Find the previous state by looking at incoming transitions
   */
  _findPreviousState(states, targetStateName) {
    const previousStates = [];
    
    // Look through all states
    for (const [stateName, stateConfig] of Object.entries(states)) {
      const transitions = stateConfig.on || {};
      
      // Check if any transition leads to our target state
      for (const [event, targetState] of Object.entries(transitions)) {
        if (targetState === targetStateName) {
          previousStates.push(stateName);
        }
      }
    }
    
    // Return the most likely previous state
    // Priority: draft > filling > empty > pending > created
    const priority = ['draft', 'filling', 'empty', 'pending', 'created'];
    
    for (const preferred of priority) {
      if (previousStates.includes(preferred)) {
        return preferred;
      }
    }
    
    // Return first one found, or null
    return previousStates[0] || null;
  }
  
  /**
   * Build template context from metadata
   * 
   * This is the main orchestration method that builds the complete
   * context object for template rendering.
   */
  _buildContext(metadata, platform) {
    const implClassName = metadata.className;
    const targetStatus = metadata.status;
    const actionName = this._generateActionName(metadata);
    const testFileName = this._generateFileName(metadata, platform);
    
    // Platform detection
    const isPlaywright = platform === 'web' || platform === 'cms';
    const isMobile = platform.startsWith('mobile-');
    
    // Prerequisites
    const requiresPrerequisites = !!metadata.previousStatus;
    const hasPrerequisites = requiresPrerequisites;
    
    // Action description
    const actionDescription = metadata.actionDetails?.description || 
                              `Transition to ${targetStatus} state`;
    
    // Entity logic
    const hasEntityLogic = this._shouldGenerateEntityLogic(metadata);
    const entityName = this._inferEntityName(metadata);
    
    // Delta fields (from entry: assign)
    const deltaFields = this._extractDeltaFields(metadata.entry, targetStatus);
    const hasDeltaLogic = deltaFields.length > 0;
    
    // Action details
    const hasActionDetails = !!metadata.actionDetails;
    
    // ‚ú® Section-based workflow detection and context building
    const usesSection = metadata.usesSection || false;
    let sectionContext = {};
    
    if (usesSection) {
      sectionContext = this._buildSectionContext(metadata);
    }
    
    // Test cases
    const testCases = this._generateTestCases(metadata, entityName);
    
    // ‚ú® Calculate import paths
    const paths = this._calculateImportPaths();
    
    // Validation info
    const hasValidation = !!metadata.mirrorsOn;
    const screenValidations = hasValidation ? 
      this._extractScreenValidations(metadata.mirrorsOn, platform, targetStatus) : [];
    
    // Build complete context
    const context = {
      // Header
      timestamp: new Date().toISOString(),
      implClassName,
      platform,
      platformUpper: platform.toUpperCase(),
      targetStatus,
      previousStatus: metadata.previousStatus,
      
      // Platform
      isPlaywright,
      isMobile,
      
      // Paths (calculated based on config and structure)
      testContextPath: paths.testContext,
      testPlannerPath: paths.testPlanner,
      expectImplicationPath: paths.expectImplication,
      
      // Function
      actionName,
      actionDescription,
      testFileName,
      testDescription: `${targetStatus} State Transition`,
      
      // Prerequisites
      requiresPrerequisites,
      hasPrerequisites,
      prerequisiteImports: [],
      
      // Options
      optionParams: this._generateOptionParams(isPlaywright, hasEntityLogic, usesSection),
      
      // Entity logic
      hasEntityLogic,
      entityName,
      
      // Action
      hasActionDetails,
      actionDetails: metadata.actionDetails,
      triggerButton: metadata.triggerButton,
      navigationExample: this._generateNavigationExample(platform, metadata),
      actionExample: this._generateActionExample(metadata, platform),
      appObjectName: isMobile ? 'app' : 'page',
      
      // Delta
      hasDeltaLogic,
      deltaFields,
      
      // ‚ú® Section workflow context
      usesSection,
      ...sectionContext,
      
      // Validation
      hasValidation,
      screenValidations,
      
      // Helper functions
      hasHelperFunctions: false,
      helperFunctions: [],
      
      // Test cases
      testCases,
      defaultTestDataPath: this._resolvePathFromConfig('testData') + '/shared.json',
      
      // Change log
      changeLogLabel: `${targetStatus} ${hasEntityLogic ? entityName : usesSection ? 'Page' : 'State'}`,
    };
    
    return context;
  }
  
  /**
   * Build section-specific context
   * 
   * Uses configuration-based discovery with metadata override
   */
  _buildSectionContext(metadata) {
    const sectionType = metadata.sectionType;
    
    if (!sectionType) {
      throw new Error('Section-based workflow requires sectionType in metadata');
    }
    
    // Attempt discovery if enabled and explicit path not provided
    let sectionInfo = null;
    
    if (this.config.generator.enableDiscovery && !metadata.sectionPath) {
      console.log(`   üîç Discovering section: ${sectionType}`);
      sectionInfo = this._discoverSection(sectionType);
      
      if (!sectionInfo) {
        return this._handleMissingSection(sectionType, metadata);
      }
    } else if (metadata.sectionPath) {
      // Explicit path provided - analyze that file
      console.log(`   üìç Using explicit section path: ${metadata.sectionPath}`);
      sectionInfo = this._analyzeSection(
        this._resolveRelativePath(metadata.sectionPath),
        sectionType
      );
    } else {
      // Discovery disabled and no explicit path
      return this._handleMissingSection(sectionType, metadata);
    }
    
    // Build section context from discovered/explicit info
    return {
      sectionType,
      sectionClass: sectionInfo.className,
      sectionPath: sectionInfo.relativePath,
      scenarios: sectionInfo.scenarios.join(', '),
      scenariosJson: JSON.stringify(sectionInfo.scenarios),
      defaultScenario: sectionInfo.scenarios[0] || 'DEFAULT',
      locale: metadata.locale || 'en',
      
      // Supporting paths - use explicit from metadata or resolve from config
      loginScreenPath: metadata.loginScreenPath || this._resolveScreenPath('login'),
      addPageScreenPath: metadata.addPageScreenPath || this._resolveScreenPath('addPage'),
      credentialsPath: metadata.credentialsPath || this._resolvePathFromConfig('credentials'),
      credentialKey: metadata.credentialKey || this.config.conventions.defaultCredentialKey
    };
  }
  
  /**
   * Handle missing section based on configuration
   */
  _handleMissingSection(sectionType, metadata) {
    const errorMsg = `Cannot find section: ${sectionType}. ` +
                     `Provide explicit sectionPath in metadata or check ai-testing.config.js`;
    
    switch (this.config.generator.onMissingFile) {
      case 'error':
        throw new Error(errorMsg);
      
      case 'warn':
        console.warn(`‚ö†Ô∏è  ${errorMsg}`);
        return this._getFallbackSectionContext(sectionType, metadata);
      
      case 'skip':
        console.log(`‚è≠Ô∏è  ${errorMsg} - Skipping`);
        throw new Error(errorMsg);  // Will be caught by caller
      
      case 'template':
        console.warn(`‚ö†Ô∏è  ${errorMsg} - Generating template`);
        return this._getFallbackSectionContext(sectionType, metadata);
      
      default:
        throw new Error(errorMsg);
    }
  }
  
  /**
   * Get fallback section context when discovery fails
   */
  _getFallbackSectionContext(sectionType, metadata) {
    return {
      sectionType,
      sectionClass: metadata.sectionClass || 'UnknownSection',
      sectionPath: '???/MANUALLY-ADD-PATH',
      scenarios: metadata.scenarios?.join(', ') || 'DEFAULT',
      scenariosJson: JSON.stringify(metadata.scenarios || ['DEFAULT']),
      defaultScenario: metadata.scenarios?.[0] || 'DEFAULT',
      locale: metadata.locale || 'en',
      loginScreenPath: '???/MANUALLY-ADD-PATH',
      addPageScreenPath: '???/MANUALLY-ADD-PATH',
      credentialsPath: '???/MANUALLY-ADD-PATH',
      credentialKey: 'default'
    };
  }
  
  /**
   * Discover section class by scanning configured locations
   */
  _discoverSection(sectionType) {
    // Generate search paths based on configuration
    const searchPaths = this._generateSectionSearchPaths(sectionType);
    
    for (const searchPath of searchPaths) {
      if (fs.existsSync(searchPath)) {
        console.log(`   ‚úÖ Found section: ${searchPath}`);
        return this._analyzeSection(searchPath, sectionType);
      }
    }
    
    console.warn(`   ‚ö†Ô∏è  Section not found. Searched: ${searchPaths.join(', ')}`);
    return null;
  }
  
  /**
   * Generate possible section file paths based on configuration
   */
  _generateSectionSearchPaths(sectionType) {
    const projectRoot = this._findProjectRoot();
    const sectionsDir = this._resolvePathFromConfig('sections');
    const pattern = this.config.conventions.sectionPattern;
    
    // Generate filename variations
    const filenames = this._applyNamingPattern(pattern, sectionType);
    
    // Build full paths
    const paths = [];
    for (const filename of filenames) {
      paths.push(path.join(projectRoot, sectionsDir, filename));
    }
    
    return paths;
  }
  
  /**
   * Apply naming pattern to generate filename variations
   * 
   * Pattern: '{name}.section.js' or '{Name}Section.js'
   */
_applyNamingPattern(pattern, name) {
  const variations = [];
  
  // PRESERVE the original casing (for stayCards ‚Üí stayCards)
  variations.push(pattern.replace('{name}', name));  // ‚Üê THIS LINE ADDED
  
  // Also try lowercase
  variations.push(pattern.replace('{name}', name.toLowerCase()));
  
  // PascalCase
  variations.push(pattern.replace('{Name}', this._toPascalCase(name)));
  
  return [...new Set(variations)];
}
  
  /**
   * Analyze section file to extract metadata
   */
  _analyzeSection(sectionPath, sectionType) {
    try {
      const content = fs.readFileSync(sectionPath, 'utf-8');
      
      // Extract class name
      const classMatch = content.match(/class\s+(\w+)\s+extends/);
      const className = classMatch ? classMatch[1] : this._toPascalCase(sectionType) + 'Section';
      
      // Extract SCENARIOS
      const scenariosMatch = content.match(/static\s+SCENARIOS\s*=\s*\{([^}]+)\}/s);
      let scenarios = ['DEFAULT'];
      
      if (scenariosMatch) {
        const scenarioKeys = scenariosMatch[1].match(/(\w+)\s*:/g);
        if (scenarioKeys) {
          scenarios = scenarioKeys.map(key => key.replace(':', '').trim());
        }
      }
      
      // Calculate relative path from output dir
      const outputDir = this.options.outputDir || path.dirname(this.implFilePath);
      const relativePath = path.relative(outputDir, sectionPath);
      
      return {
        className,
        scenarios,
        relativePath: relativePath.replace(/\\/g, '/'),  // Normalize separators
        absolutePath: sectionPath
      };
    } catch (error) {
      console.error(`‚ùå Error analyzing section ${sectionPath}:`, error.message);
      return null;
    }
  }
  
  /**
   * Resolve screen path from configuration
   */
  _resolveScreenPath(screenName) {
    const projectRoot = this._findProjectRoot();
    const screenObjectsDir = this._resolvePathFromConfig('screenObjects');
    const pattern = this.config.conventions.screenPattern;
    
    // Apply naming pattern
    const filename = pattern.replace('{name}', screenName.toLowerCase());
    
    const fullPath = path.join(projectRoot, screenObjectsDir, filename);
    
    // Calculate relative path from output dir
    const outputDir = this.options.outputDir || path.dirname(this.implFilePath);
    return path.relative(outputDir, fullPath).replace(/\\/g, '/');
  }
  
  /**
   * Resolve path from configuration key
   */
  _resolvePathFromConfig(key) {
    if (!this.config.paths[key]) {
      throw new Error(`Configuration missing path for: ${key}`);
    }
    return this.config.paths[key];
  }
  
  /**
   * Resolve relative path to absolute
   */
  _resolveRelativePath(relativePath) {
    const outputDir = this.options.outputDir || path.dirname(this.implFilePath);
    return path.resolve(outputDir, relativePath);
  }
  
  /**
   * Calculate import paths for utilities
   */
  _calculateImportPaths() {
    const projectRoot = this._findProjectRoot();
    const outputDir = this.options.outputDir || path.dirname(this.implFilePath);
    const utilsDir = this._resolvePathFromConfig('utils');
    
    const utilsPath = path.join(projectRoot, utilsDir);
    
    return {
      testContext: path.relative(outputDir, path.join(utilsPath, 'TestContext')).replace(/\\/g, '/'),
      testPlanner: path.relative(outputDir, path.join(utilsPath, 'TestPlanner')).replace(/\\/g, '/'),
      expectImplication: path.relative(outputDir, path.join(utilsPath, 'ExpectImplication')).replace(/\\/g, '/')
    };
  }
  
  /**
   * Find project root by looking for package.json
   */
  _findProjectRoot() {
    let currentDir = this.implFilePath ? path.dirname(this.implFilePath) : process.cwd();
    
    for (let i = 0; i < 10; i++) {
      if (fs.existsSync(path.join(currentDir, 'package.json'))) {
        return currentDir;
      }
      
      const parentDir = path.dirname(currentDir);
      if (parentDir === currentDir) break;  // Reached root
      currentDir = parentDir;
    }
    
    // Fallback: use current directory
    return process.cwd();
  }
  
  /**
   * Extract delta fields from entry: assign
   */
  _extractDeltaFields(entry, targetStatus) {
    if (!entry || typeof entry.assignment !== 'object') {
      return [];
    }
    
    const fields = [];
    
    for (const [key, value] of Object.entries(entry.assignment)) {
      // Generate value expression for template
      let valueExpr;
      
      if (typeof value === 'function') {
        // Function: try to infer parameter name
        const funcStr = value.toString();
        
        if (funcStr.includes('event')) {
          valueExpr = `options.${key} || new Date().toISOString()`;
        } else {
          valueExpr = `'${targetStatus}'`;
        }
      } else if (typeof value === 'string') {
        valueExpr = `'${value}'`;
      } else {
        valueExpr = JSON.stringify(value);
      }
      
      fields.push({
        name: key,
        value: valueExpr
      });
    }
    
    return fields;
  }
  
  /**
   * Extract screen validations from mirrorsOn
   */
  _extractScreenValidations(mirrorsOn, platform, targetStatus) {
    if (!mirrorsOn || !mirrorsOn.UI) return [];
    
    const platformKey = platform.toUpperCase();
    const platformMirrors = mirrorsOn.UI[platformKey];
    
    if (!platformMirrors) return [];
    
    const stateMirrors = platformMirrors[targetStatus];
    
    if (!stateMirrors || !Array.isArray(stateMirrors)) return [];
    
    return stateMirrors.map((mirror) => {
      const visibleCount = mirror.visible?.length || 0;
      const hiddenCount = mirror.hidden?.length || 0;
      const checksCount = mirror.checks ? Object.keys(mirror.checks).length : 0;
      
      return {
        screenKey: targetStatus,
        screenName: mirror.screen || 'unknown',
        comment: `${mirror.description || 'Validation'} - ${visibleCount} visible, ${hiddenCount} hidden, ${checksCount} checks`
      };
    });
  }
  
  /**
   * Should generate entity logic (for arrays like bookings, users)
   */
  _shouldGenerateEntityLogic(metadata) {
    // Check if entry assigns to array paths
    if (metadata.entry && metadata.entry.assignment) {
      const keys = Object.keys(metadata.entry.assignment);
      return keys.some(key => key.includes('[') || key.endsWith('s'));
    }
    return false;
  }
  
  /**
   * Infer entity name from metadata
   */
  _inferEntityName(metadata) {
    if (metadata.entry && metadata.entry.assignment) {
      const keys = Object.keys(metadata.entry.assignment);
      const arrayKey = keys.find(key => key.includes('[') || key.endsWith('s'));
      
      if (arrayKey) {
        // Extract entity name from array key
        const match = arrayKey.match(/(\w+)s?\[/);
        if (match) return match[1];
        
        // If ends with 's', remove it
        if (arrayKey.endsWith('s')) {
          return arrayKey.slice(0, -1);
        }
      }
    }
    
    return 'entity';
  }
  
  /**
   * Generate option parameters for function signature
   */
  _generateOptionParams(isPlaywright, hasEntityLogic, usesSection) {
    const params = [];
    
    if (usesSection) {
      params.push({
        type: 'string',
        name: 'sectionType',
        description: 'Type of section to use'
      });
      params.push({
        type: 'string',
        name: 'scenario',
        description: 'Scenario to execute'
      });
    }
    
    if (hasEntityLogic) {
      params.push({
        type: 'number',
        name: 'index',
        description: 'Index of entity to process'
      });
    }
    
    return params;
  }
  
  /**
   * Generate test cases
   */
  _generateTestCases(metadata, entityName) {
    const testCases = [];
    
    if (this._shouldGenerateEntityLogic(metadata)) {
      testCases.push({
        description: `Process first ${entityName}`,
        params: 'index: 0'
      });
    } else {
      testCases.push({
        description: `Execute ${metadata.status} transition`,
        params: null
      });
    }
    
    return testCases;
  }
  
  /**
   * Generate navigation example
   */
  _generateNavigationExample(platform, metadata) {
    // Return generic commented examples
    const examples = ['// await navigateTo(screen);'];
    return examples.join('\n');
  }
  
  /**
   * Generate action example
   */
  _generateActionExample(metadata, platform) {
    if (metadata.triggerButton) {
      return `// await page.getByRole('button', { name: '${metadata.triggerButton}' }).click();`;
    }
    return '// await performAction();';
  }
  
  /**
   * Generate action name (GENERIC - uses metadata or conventions)
   */
  _generateActionName(metadata) {
    // 1. Check if explicitly provided
    if (metadata.actionName) {
      return metadata.actionName;
    }
    
    // 2. Check in setup
    if (metadata.setup && metadata.setup[0]?.actionName) {
      return metadata.setup[0].actionName;
    }
    
    // 3. Infer from status using generic conventions
    return this._inferActionName(metadata.status);
  }
  
  /**
   * Generate file name (GENERIC - uses metadata or conventions)
   */
  _generateFileName(metadata, platform) {
    // 1. Check if explicitly provided
    if (metadata.testFile) {
      return metadata.testFile;
    }
    
    // 2. Check in setup
    if (metadata.setup && metadata.setup[0]?.testFile) {
      return metadata.setup[0].testFile;
    }
    
    // 3. Generate from action name
    const actionName = this._generateActionName(metadata);
    const action = this._toPascalCase(actionName);
    const platformSuffix = this._getPlatformSuffix(platform);
    
    return `${action}-${platformSuffix}-UNIT.spec.js`;
  }
  
  /**
   * Get platform suffix for file name
   */
  _getPlatformSuffix(platform) {
    const mapping = {
      'web': 'Web',
      'cms': 'CMS',
      'dancer': 'Dancer',
      'manager': 'Manager'
    };
    
    return mapping[platform] || 'Web';
  }
  
  /**
   * Validate context before rendering
   */
  _validateContext(context) {
    const required = ['implClassName', 'actionName', 'targetStatus', 'testFileName'];
    
    for (const field of required) {
      if (!context[field]) {
        throw new Error(`Missing required context field: ${field}`);
      }
    }
    
    return true;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // GENERIC HELPERS (NO DOMAIN KNOWLEDGE!)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * Convert string to camelCase
   */
  _toCamelCase(str) {
    if (!str) return '';
    
    let result = str.charAt(0).toLowerCase() + str.slice(1);
    result = result.replace(/[_-](\w)/g, (_, c) => c.toUpperCase());
    
    return result;
  }
  
  /**
   * Convert string to PascalCase
   */
  _toPascalCase(str) {
    if (!str) return '';
    
    let result = str.charAt(0).toUpperCase() + str.slice(1);
    result = result.replace(/[_-](\w)/g, (_, c) => c.toUpperCase());
    
    return result;
  }
  
  /**
   * Infer action name from status (generic)
   */
  _inferActionName(status) {
    if (!status) return 'action';
    
    let name = this._toCamelCase(status);
    
    // Remove common suffixes
    if (name.endsWith('ed') && name.length > 3) {
      name = name.slice(0, -2);
    } else if (name.endsWith('ing') && name.length > 4) {
      name = name.slice(0, -3);
    }
    
    return name;
  }
}

export default UnitTestGenerator;