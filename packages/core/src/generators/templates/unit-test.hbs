// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTO-GENERATED UNIT TEST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Generated at: {{timestamp}}
{{#if hasTransitionContext}}
// Transition: {{transitionFrom}} â†’ {{transitionTo}} ({{transitionEvent}})
{{/if}}
// From: {{implClassName}}
// Platform: {{platform}}
// Target Status: {{targetStatus}}
{{#if isVerify}}
// Test Mode: VERIFY (checks UI only, does not induce state)
{{else}}
// Test Mode: INDUCER (performs action + saves state)
{{/if}}

{{#if isPlaywright}}
const { test, expect, devices } = require('@playwright/test');
{{/if}}
const TestContext = require('{{testContextPath}}');
const TestPlanner = require('{{testPlannerPath}}');
const {{implClassName}} = require('./{{implClassName}}.js');
{{#if (or hasUIValidation hasStoreAs hasAnyValidation useOrderedScreens)}}
const ExpectImplication = require('{{expectImplicationPath}}');
{{/if}}
{{#if isVerify}}
const NavigationActions = require('{{navigationActionsPath}}');
{{/if}}
{{#if setupConfig}}
// âœ… Setup helper from project config
const { {{setupConfig.function}} } = require('{{{setupConfig.relativePath}}}');
{{/if}}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… PRE-FLIGHT CHECK - Runs BEFORE app starts!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const testDataPath = process.env.TEST_DATA_PATH || "{{defaultTestDataPath}}";

{{#unless isPlaywright}}
if (!process.env.SKIP_PREFLIGHT_CHECK) {
  console.log('ğŸš€ Running pre-flight check...');
  TestPlanner.preFlightCheck({{implClassName}}, testDataPath);
}
{{/unless}}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ ENTITY FIELD REQUIREMENTS (Setup Concerns)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
{{#if meta.requires}}
{{#each meta.requires}}
{{#if (contains @key '.')}}
// âš ï¸  Required: {{@key}} {{formatRequirement @key this}}
{{/if}}
{{/each}}
{{/if}}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * âœ… EXPORTED FUNCTION - {{transitionDescription}}
 * 
 * {{#if isVerify}}
 * This function VERIFIES the "{{targetStatus}}" state.
 * âš ï¸  NOTE: Does NOT induce state, only validates it exists.
 * {{else}}
 * This function INDUCES the "{{targetStatus}}" state by:
 * 1. Loading test data
 * 2. Performing the state-inducing action
 * 3. Saving the state change
 * 
 * âš ï¸  NOTE: Does NOT validate UI - validation happens in the test.
 * {{/if}}
 * 
 * @param {string} testDataPath - Path to testData JSON file
 * @param {object} options - Options
{{#if isPlaywright}}
 * @param {Page} options.page - Playwright page object
{{else}}
 * @param {Driver} options.driver - WebdriverIO driver object
{{/if}}
{{#each optionParams}}
 * @param {{type}} options.{{name}} - {{description}}
{{/each}}
 * @returns {Promise<TestContext>} Updated context
 */
const {{actionName}} = async (testDataPath, options = {}) => {
  {{#if isPlaywright}}
  const { page } = options;
  {{else}}
  const { driver } = options;
  {{/if}}
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STEP 1: Load TestData
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ctx = TestContext.load({{implClassName}}, testDataPath);
  
  {{#if hasTransitionConditions}}
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ğŸ”’ TRANSITION CONDITIONS CHECK
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const transitionConditions = {{{transitionConditionsJson}}};
  const conditionsResult = TestPlanner.evaluateConditions(transitionConditions, ctx.data);
  
  if (!conditionsResult.met) {
    console.log('\nâ­ï¸ Transition conditions not met - skipping action');
    if (conditionsResult.results) {
      for (const blockResult of conditionsResult.results) {
        if (!blockResult.met && blockResult.checks) {
          for (const check of blockResult.checks) {
            if (!check.met) {
              console.log(`   âŒ ${check.field} ${check.operator} ${JSON.stringify(check.expected)} (actual: ${JSON.stringify(check.actual)})`);
            }
          }
        }
      }
    }
    return ctx; // Return without executing action
  }
  console.log('âœ… Transition conditions passed');
{{/if}}
  console.log(`   Target Status: {{targetStatus}}`);
  console.log(`   Current Status: ${ctx.data.status || 'Unknown'}`);
{{#if hasTransitionContext}}
  console.log(`   Transition: {{transitionFrom}} â†’ {{transitionTo}}`);
  console.log(`   Event: {{transitionEvent}}`);
{{/if}}
{{#if isVerify}}
  console.log(`   Test Mode: VERIFY (checks only)`);
{{else}}
  console.log(`   Test Mode: INDUCER (action only)`);
{{/if}}

{{#if actionDetails.requires}}
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âš ï¸  TRANSITION REQUIREMENTS CHECK
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log('\nğŸ”’ Checking transition requirements...');
  const transitionMissing = [];
  
{{#each actionDetails.requires}}
{{#if (isNegatedField @key)}}
{{#if (isContainsObject this)}}
  // Check: {{removeNegation @key}} must NOT contain {{getContainsValue this}}
  {
    const fieldPath = '{{removeNegation @key}}';
    const actualValue = fieldPath.split('.').reduce((obj, key) => obj?.[key], ctx.data);
    const valueToCheck = '{{getContainsValue this}}'.startsWith('ctx.data.') 
      ? '{{getContainsValue this}}'.replace('ctx.data.', '').split('.').reduce((obj, key) => obj?.[key], ctx.data)
      : '{{getContainsValue this}}';
    if (Array.isArray(actualValue) && actualValue.includes(valueToCheck)) {
      transitionMissing.push(`${fieldPath} must NOT contain "${valueToCheck}" (actual: [${actualValue.join(', ')}])`);
    }
  }
{{else}}
  // Check: {{removeNegation @key}} must NOT be {{jsonInline this}}
  {
    const fieldPath = '{{removeNegation @key}}';
    const actualValue = fieldPath.split('.').reduce((obj, key) => obj?.[key], ctx.data);
    if (actualValue === {{json this}}) {
      transitionMissing.push(`${fieldPath} must NOT be {{jsonInline this}} (actual: ${actualValue})`);
    }
  }
{{/if}}
{{else}}
{{#if (isContainsObject this)}}
  // Check: {{@key}} must contain {{getContainsValue this}}
  {
    const fieldPath = '{{@key}}';
    const actualValue = fieldPath.split('.').reduce((obj, key) => obj?.[key], ctx.data);
    const valueToCheck = '{{getContainsValue this}}'.startsWith('ctx.data.') 
      ? '{{getContainsValue this}}'.replace('ctx.data.', '').split('.').reduce((obj, key) => obj?.[key], ctx.data)
      : '{{getContainsValue this}}';
    if (!Array.isArray(actualValue) || !actualValue.includes(valueToCheck)) {
      transitionMissing.push(`${fieldPath} must contain "${valueToCheck}" (actual: ${JSON.stringify(actualValue)})`);
    }
  }
{{else if (isBoolean this)}}
  // Check: {{@key}} must be {{this}}
  {
    const fieldPath = '{{@key}}';
    const actualValue = fieldPath.split('.').reduce((obj, key) => obj?.[key], ctx.data);
    if (actualValue !== {{this}}) {
      transitionMissing.push(`${fieldPath} must be {{this}} (actual: ${actualValue})`);
    }
  }
{{else}}
  // Check: {{@key}} must be "{{this}}"
  {
    const fieldPath = '{{@key}}';
    const actualValue = fieldPath.split('.').reduce((obj, key) => obj?.[key], ctx.data);
    if (actualValue !== '{{this}}') {
      transitionMissing.push(`${fieldPath} must be "{{this}}" (actual: ${actualValue})`);
    }
  }
{{/if}}
{{/if}}
{{/each}}
  
  if (transitionMissing.length > 0) {
    console.error('\nâŒ Transition requirements not met:');
    transitionMissing.forEach(msg => console.error(`   - ${msg}`));
    throw new Error(`Cannot execute {{transitionEvent}}: ${transitionMissing.join('; ')}`);
  }
  console.log('   âœ… All transition requirements satisfied');
{{/if}}

{{#if isVerify}}
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âš ï¸  VERIFY MODE - State Must Already Exist
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (ctx.data.status !== '{{targetStatus}}') {
    throw new Error(
      `âŒ Verification failed: State mismatch\n` +
      `   Expected: {{targetStatus}}\n` +
      `   Current: ${ctx.data.status}\n\n` +
      `ğŸ’¡ Run the inducer test first to create this state.`
    );
  }
  
  console.log('âœ… State verified: {{targetStatus}}');
  return ctx;
{{else}}
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STEP 2: Determine Action Scope
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{{#if hasEntityLogic}}
  let targets = [];
  let isGlobalAction = false;
  
  if (!ctx.data.{{entityName}}s || !Array.isArray(ctx.data.{{entityName}}s) || ctx.data.{{entityName}}s.length === 0) {
    console.log('\nâœ… Global state action');
    isGlobalAction = true;
    targets = [{ isGlobal: true }];
  } else {
    if (options.indices && Array.isArray(options.indices)) {
      targets = options.indices.map(i => ctx.data.{{entityName}}s[i]);
    } else if (options.index !== undefined) {
      targets = [ctx.data.{{entityName}}s[options.index]];
    } else {
{{#if previousStatus}}
      const matchingEntities = ctx.data.{{entityName}}s.filter(e => e.status === '{{previousStatus}}');
      if (!matchingEntities || matchingEntities.length === 0) {
        console.log('\nâœ… No matching entities, treating as global action');
        isGlobalAction = true;
        targets = [{ isGlobal: true }];
      } else {
        targets = [matchingEntities[0]];
        console.log(`\nâœ… Processing ${targets.length} {{entityName}}(s)...`);
      }
{{else}}
      targets = [ctx.data.{{entityName}}s[0]];
      console.log(`\nâœ… Processing ${targets.length} {{entityName}}(s)...`);
{{/if}}
    }
  }
{{else}}
  console.log('\nâœ… Global state action');
  let isGlobalAction = true;
{{/if}}
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STEP 3: Perform Action (NO validation here!)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
{{#if hasNavigation}}
  // Initialize navigation helper
  const {{navigation.className}} = require('{{{navigation.path}}}');
  const {{navigation.instance}} = new {{navigation.className}}(ctx.data);
  
  console.log('\nğŸ§­ Navigating to action screen...');
  await {{navigation.instance}}.{{navigation.method}}({{#each navigation.args}}{{this}}{{#unless @last}}, {{/unless}}{{/each}});
  console.log('âœ… Navigation complete');
{{/if}}

{{#if hasActionDetails}}
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¬ ACTION LOGIC - Generated from actionDetails
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
{{#if actionDetails.imports}}
  // Initialize screen objects
{{#each actionDetails.imports}}
  const {{className}} = require('{{{relativePath}}}');
{{#if ../isPlaywright}}
  const {{varName}} = new {{className}}(page, ctx.data.lang || 'en', ctx.data.device || 'desktop');
{{else}}
  const {{varName}} = new {{className}}(ctx.data.lang || 'en');
{{/if}}
{{/each}}
{{/if}}
  
  console.log('\nğŸ¬ Executing action: {{actionDetails.description}}');
  
{{#if actionDetails.steps}}
  // Initialize storedVars for step conditions
  const storedVars = {};
  
{{#each actionDetails.steps}}
  // Step {{addOne @index}}: {{description}}
{{#if hasConditions}}
  // ğŸ”’ Step has conditions - check before executing
  if (TestPlanner.evaluateStepConditions({{{conditionsJson}}}, ctx.data, storedVars)) {
{{/if}}
{{#if storeAs}}
{{#if entity}}
  const {{storeAsKey}} = await {{instance}}.{{method}}({{#each argsArray}}{{#if (isContextField this)}}ctx.data.{{../entity}}.{{removeCtxDataPrefix this}}{{else}}{{{this}}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}});
{{else}}
  const {{storeAsKey}} = await {{instance}}.{{method}}({{{args}}});
{{/if}}
  // ğŸ’¾ Store captured value
  ExpectImplication.storeValue('{{storeAsKey}}', {{storeAsKey}});
  storedVars.{{storeAsKey}} = {{storeAsKey}};
{{#if storeAsGlobal}}
  ctx.data.{{storeAsKey}} = {{storeAsKey}};
  console.log('   ğŸ’¾ Stored {{storeAsKey}}:', typeof {{storeAsKey}} === 'object' ? JSON.stringify({{storeAsKey}}).slice(0, 100) + '...' : {{storeAsKey}});
{{else if entity}}
  if (!ctx.data.{{entity}}) ctx.data.{{entity}} = {};
  ctx.data.{{entity}}.{{storeAsKey}} = {{storeAsKey}};
  console.log('   ğŸ’¾ Stored {{entity}}.{{storeAsKey}}:', typeof {{storeAsKey}} === 'object' ? JSON.stringify({{storeAsKey}}).slice(0, 100) + '...' : {{storeAsKey}});
{{else}}
  ctx.data.{{storeAsKey}} = {{storeAsKey}};
  console.log('   ğŸ’¾ Stored {{storeAsKey}}:', typeof {{storeAsKey}} === 'object' ? JSON.stringify({{storeAsKey}}).slice(0, 100) + '...' : {{storeAsKey}});
{{/if}}
{{else}}
{{#if entity}}
  await {{instance}}.{{method}}({{#each argsArray}}{{#if (isContextField this)}}ctx.data.{{../entity}}.{{removeCtxDataPrefix this}}{{else}}{{{this}}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}});
{{else}}
  await {{instance}}.{{method}}({{{args}}});
{{/if}}
{{/if}}
{{#if hasConditions}}
  } else {
    console.log('   â­ï¸ Skipping step {{addOne @index}}: conditions not met');
  }
{{/if}}
{{/each}}
{{/if}}
  
  console.log('âœ… Action steps completed');
{{else}}
  // TODO: Navigate to the screen where you perform this action
{{#if navigationExample}}
{{{navigationExample}}}
{{else}}
  // await navigateToScreen();
{{/if}}
  
  // TODO: Perform the state-inducing action
{{#if actionExample}}
{{{actionExample}}}
{{else}}
{{#if triggerButton}}
{{#if isPlaywright}}
  // await page.getByRole('button', { name: '{{triggerButton}}' }).click();
{{else}}
  // await driver.$('~btn{{triggerButton}}').click();
{{/if}}
{{/if}}
{{/if}}
  
  console.log('   âš ï¸  Action logic not implemented - see comments above');
{{/if}}
  
  console.log('\nâœ… Action completed (no validation)');
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STEP 4: Save Changes (Delta)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  return ctx.executeAndSave(
    '{{deltaLabel}}',
    '{{testFileName}}',
    async () => {
      const delta = {};
      const now = new Date().toISOString();
      
{{#if hasDeltaLogic}}
      // âœ¨ Generated delta from entry: assign
{{#if meta.entity}}
      // âœ… Entity-scoped state change ({{meta.entity}})
{{#each deltaFields}}
{{#if (isContextField value)}}
      delta['{{../meta.entity}}.{{name}}'] = ctx.data.{{../meta.entity}}.{{removeCtxDataPrefix value}};
{{else}}
      delta['{{../meta.entity}}.{{name}}'] = {{{value}}};
{{/if}}
{{/each}}
{{else}}
{{#if hasEntityLogic}}
      if (isGlobalAction) {
        // Global state change
{{#each deltaFields}}
        delta.{{name}} = {{{value}}};
{{/each}}
      } else {
        // Array-based entity change
        for (const target of targets) {
          const entityPath = `{{entityName}}s[${target.index || 0}]`;
          delta[entityPath] = {
{{#each deltaFields}}
            {{name}}: {{{value}}},
{{/each}}
          };
        }
      }
{{else}}
      // Global state change
{{#each deltaFields}}
      delta.{{name}} = {{{value}}};
{{/each}}
{{/if}}
{{/if}}
{{else}}
      // TODO: Customize delta based on what changed
      // delta.status = '{{targetStatus}}';
      // delta.{{targetStatus}}At = now;
{{/if}}
{{#if storeAsFields}}
      // ğŸ’¾ Auto-include storeAs values in delta
{{#each storeAsFields}}
{{#unless skipPersist}}
{{#if global}}
      if (ctx.data.{{key}} !== undefined) {
        delta.{{key}} = ctx.data.{{key}};
      }
{{else if ../meta.entity}}
      if (ctx.data.{{../meta.entity}}?.{{key}} !== undefined) {
        delta['{{../meta.entity}}.{{key}}'] = ctx.data.{{../meta.entity}}.{{key}};
      }
{{else}}
      if (ctx.data.{{key}} !== undefined) {
        delta.{{key}} = ctx.data.{{key}};
      }
{{/if}}
{{/unless}}
{{/each}}
{{/if}}
      
      return { delta };
    }
  );
{{/if}}
};

{{#if hasHelperFunctions}}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{{#each helperFunctions}}
/**
 * {{description}}
 */
async function {{name}}({{params}}) {
{{#if code}}
{{code}}
{{else}}
  // TODO: Implement {{name}}
  throw new Error('Helper function not implemented: {{name}}');
{{/if}}
}

{{/each}}
{{/if}}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST REGISTRATION - Validation happens HERE!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const shouldSkipRegistration = process.env.SKIP_UNIT_TEST_REGISTRATION === 'true';

if (!shouldSkipRegistration) {
{{#if isPlaywright}}
  test.describe("UNIT: {{transitionDescription}} ({{platform}} - {{#if isVerify}}VERIFY{{else}}INDUCER{{/if}})", () => {
    test.setTimeout(120000);
    
    const testDataPath = process.env.TEST_DATA_PATH || "{{defaultTestDataPath}}";
    
    let page;
    let context;
    let testPassed = false;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… SETUP - BeforeAll Hook
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    test.beforeAll(async ({ browser }) => {
{{#if setupConfig}}
      // Using project setup helper: {{setupConfig.function}}
      console.log('ğŸš€ Running setup: {{setupConfig.function}}');
      page = await {{setupConfig.function}}(browser);
      context = page.context();
      console.log('âœ… Setup complete');
{{else}}
      // Default setup (no project-specific helper configured)
      console.log('ğŸš€ Running default setup...');
      {{#if deviceConfig}}
      {{#if deviceConfig.isMobile}}
      // Mobile device setup
      const {{deviceConfig.deviceName}} = devices['{{deviceConfig.deviceName}}'];
      context = await browser.newContext({
        ...{{deviceConfig.deviceName}},
      });
      {{else}}
      // Desktop setup
      context = await browser.newContext();
      {{/if}}
      {{else}}
      context = await browser.newContext();
      {{/if}}
      page = await context.newPage();
      {{#if baseURL}}
      await page.goto('{{baseURL}}');
      {{else}}
      await page.goto('/');
      {{/if}}
      console.log('âœ… Default setup complete');
{{/if}}
    });
    
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… TEARDOWN - AfterAll Hook
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    test.afterAll(async () => {
      console.log('ğŸ§¹ Cleaning up...');
      
      // Cleanup delta file based on test result
      await TestContext.cleanup(testDataPath, { passed: testPassed });
      
      if (context) {
        await context.close();
      }
      console.log('âœ… Cleanup complete');
    });

    test("{{#if isVerify}}Verify{{else}}Execute{{/if}} {{transitionDescription}}", async () => {
      const ctx = TestContext.load({{implClassName}}, testDataPath);
      
{{#if isVerify}}
      await TestPlanner.checkState({{implClassName}}, ctx.data, {
        mode: 'verify'
      });
      
      const result = await {{actionName}}(testDataPath, { page });
{{else}}
      await TestPlanner.checkOrThrow({{implClassName}}, ctx.data, { 
        page, 
        testDataPath 
      });
      
      const result = await {{actionName}}(testDataPath, { page });
      
      result.save(testDataPath);
      console.log('   ğŸ’¾ State saved to:', testDataPath);
{{/if}}

{{#if useOrderedScreens}}
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // âœ… PHASE 3.7: ORDERED SCREEN VALIDATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log('\nğŸ” Validating {{targetStatus}} UI ({{orderedScreenCount}} screen(s) in order)...');
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ğŸ“¦ REQUIRE ALL POMs ONCE (deduplicated)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{{#each uniquePomRequires}}
      const {{className}} = require('{{{path}}}');
{{/each}}
      
{{#each orderedScreens}}
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ğŸ“º Screen {{position}}/{{totalScreens}}: {{screenKey}} (order: {{order}})
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log('\n   ğŸ“º Screen {{position}}/{{totalScreens}}: {{screenKey}}');
      
{{#if hasNavigation}}
      // ğŸ§­ Navigate to screen
      console.log('   ğŸ§­ Navigating: {{navigation.instanceName}}.{{navigation.method}}()');
      const {{navigation.instanceName}} = new {{navigation.className}}(page, result.data.lang || 'en', result.data.device || 'desktop');
      await {{navigation.instanceName}}.{{navigation.method}}({{{navigation.resolvedArgsString}}});
      console.log('   âœ… Navigation complete');
{{/if}}
      
{{#if hasPom}}
      // Initialize screen instance
      const {{pomInstance}} = new {{pomClassName}}(page, result.data.lang || 'en', result.data.device || 'desktop');
{{/if}}
      
{{#if useExpectImplication}}
      // âœ… ExpectImplication handles blocks internally
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{pomInstance}}
      );
{{else if useRawValidation}}
      // ğŸ”§ Raw validation ({{rawValidationReason}})
{{#if hasExternalPoms}}
      // Initialize external POM instances for function calls
{{#each externalPoms}}
      const {{instanceName}} = new {{className}}(page, result.data.lang || 'en', result.data.device || 'desktop');
{{/each}}
{{/if}}
{{#each blocks}}
{{#if (eq blockType 'function-call')}}
      // Block {{position}}: {{description}}
      {{{callCode}}}
{{else if (eq blockType 'custom-code')}}
      // Block {{position}}: {{description}}
{{#if wrapInTestStep}}
      await test.step('{{testStepName}}', async () => {
{{{formattedCode}}}
      });
{{else}}
{{{formattedCode}}}
{{/if}}
{{else if (eq blockType 'ui-assertion')}}
      // Block {{position}}: {{description}}
{{#each assertions}}
      {{{expectCode}}}
{{/each}}
{{/if}}
{{/each}}
{{else if hasLegacyAssertions}}
      // ğŸ“‹ Legacy validation (visible/hidden arrays)
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{pomInstance}}
      );
{{else if hasPom}}
      // ğŸ“‹ Default validation via ExpectImplication
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{pomInstance}}
      );
{{/if}}
      console.log('   âœ… {{screenKey}} validation passed');
{{/each}}
      
      console.log('\nâœ… All ordered screen validations passed');
{{else if hasUIValidation}}
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // âœ… LEGACY VALIDATION (single screen, backward compatible)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log('\nğŸ” Validating {{targetStatus}} UI on {{platform}}...');
      
{{#each validationScreens}}
{{#if @first}}
      console.log('   ğŸ” Validating {{screenKey}}...');
      
{{#if pomClassName}}
      // âœ… Require and instantiate screen
      const {{pascalCase screenKey}}Screen = require('{{{../actionDetails.imports.[0].relativePath}}}');
      const {{screenKey}} = new {{pascalCase screenKey}}Screen(page, result.data.lang || 'en', result.data.device || 'desktop');
{{else}}
{{#if ../actionDetails.imports.[0]}}
      // âœ… Require and instantiate screen
      const {{../actionDetails.imports.[0].className}} = require('{{{../actionDetails.imports.[0].relativePath}}}');
      const {{screenKey}} = new {{../actionDetails.imports.[0].className}}(page, result.data.lang || 'en', result.data.device || 'desktop');
{{/if}}
{{/if}}
      
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{screenKey}}
      );
      console.log('   âœ… {{screenKey}} validation passed');
{{else}}
      // â­ï¸ TODO: Uncomment and add navigation to {{screenKey}}
      // console.log('   ğŸ” Validating {{screenKey}}...');
      // await NavigationActions.navigateTo{{pascalCase screenKey}}(page, result.data);
{{#if pomClassName}}
      // const {{pascalCase screenKey}}Screen = require('../../../path/to/{{screenKey}}.screen.js');
      // const {{screenKey}} = new {{pascalCase screenKey}}Screen(page, result.data.lang || 'en', result.data.device || 'desktop');
{{else}}
      // const {{screenKey}} = new SomeScreen(page, result.data.lang || 'en', result.data.device || 'desktop');
{{/if}}
      // await ExpectImplication.validateImplications(
      //   {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
      //   result.data,
      //   {{screenKey}}
      // );
      // console.log('   âœ… {{screenKey}} validation passed');
{{/if}}
{{/each}}
      
  result.save(testDataPath);
      console.log('   ğŸ’¾ State saved to:', testDataPath);
{{/if}}
      testPassed = true;
    });
  });
{{else}}
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WEBDRIVERIO / APPIUM TEST
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  describe("UNIT: {{transitionDescription}} ({{platform}} - {{#if isVerify}}VERIFY{{else}}INDUCER{{/if}})", () => {
    const testDataPath = process.env.TEST_DATA_PATH || "tests/data/shared.json";
    
    {{#if setupConfig}}
    // âœ… Setup helper from project config
    before(async () => {
      console.log('ğŸš€ Running setup: {{setupConfig.function}}');
      // Note: WebdriverIO setup is typically handled by wdio.conf.js
      // This is a hook for any additional setup needed
    });
    {{/if}}
    
    it("{{#if isVerify}}Verify{{else}}Execute{{/if}} {{transitionDescription}}", async () => {
      const ctx = TestContext.load({{implClassName}}, testDataPath);
      
{{#if isVerify}}
      await TestPlanner.checkState({{implClassName}}, ctx.data, {
        mode: 'verify'
      });
      
      const result = await {{actionName}}(testDataPath, { driver });
{{else}}
      await TestPlanner.checkOrThrow({{implClassName}}, ctx.data, { 
        driver,
        testDataPath 
      });
      
      const result = await {{actionName}}(testDataPath, { driver });
      
      result.save(testDataPath);
      console.log('   ğŸ’¾ State saved to:', testDataPath);
{{/if}}
      
{{#if useOrderedScreens}}
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // âœ… PHASE 3.7: ORDERED SCREEN VALIDATION (APPIUM)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log('\nğŸ” Validating {{targetStatus}} UI ({{orderedScreenCount}} screen(s) in order)...');
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ğŸ“¦ REQUIRE ALL POMs ONCE (deduplicated)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{{#each uniquePomRequires}}
      const {{className}} = require('{{{path}}}');
{{/each}}
      
{{#each orderedScreens}}
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ğŸ“º Screen {{position}}/{{totalScreens}}: {{screenKey}} (order: {{order}})
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log('\n   ğŸ“º Screen {{position}}/{{totalScreens}}: {{screenKey}}');
      
{{#if hasNavigation}}
      // ğŸ§­ Navigate to screen
      console.log('   ğŸ§­ Navigating: {{navigation.instanceName}}.{{navigation.method}}()');
      const {{navigation.instanceName}} = new {{navigation.className}}(result.data.lang || 'en');
      await {{navigation.instanceName}}.{{navigation.method}}({{{navigation.resolvedArgsString}}});
      console.log('   âœ… Navigation complete');
{{/if}}
      
{{#if hasPom}}
      // Initialize screen instance
      const {{pomInstance}} = new {{pomClassName}}(result.data.lang || 'en');
{{/if}}
      
{{#if useExpectImplication}}
      // âœ… ExpectImplication handles blocks internally
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{pomInstance}}
      );
{{else if useRawValidation}}
      // ğŸ”§ Raw validation ({{rawValidationReason}})
{{#if hasExternalPoms}}
      // Initialize external POM instances for function calls
{{#each externalPoms}}
      const {{instanceName}} = new {{className}}(result.data.lang || 'en');
{{/each}}
{{/if}}
{{#each blocks}}
{{#if (eq blockType 'function-call')}}
      // Block {{position}}: {{description}}
      {{{callCode}}}
{{else if (eq blockType 'custom-code')}}
      // Block {{position}}: {{description}}
{{{formattedCode}}}
{{else if (eq blockType 'ui-assertion')}}
      // Block {{position}}: {{description}}
{{#each assertions}}
      {{{expectCode}}}
{{/each}}
{{/if}}
{{/each}}
{{else if hasLegacyAssertions}}
      // ğŸ“‹ Legacy validation (visible/hidden arrays)
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{pomInstance}}
      );
{{else if hasPom}}
      // ğŸ“‹ Default validation via ExpectImplication
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{pomInstance}}
      );
{{/if}}
      console.log('   âœ… {{screenKey}} validation passed');
{{/each}}
      
      console.log('\nâœ… All ordered screen validations passed');
{{else if hasUIValidation}}
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // âœ… LEGACY VALIDATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      console.log('\nğŸ” Validating {{targetStatus}} UI on {{platform}}...');
      
{{#each validationScreens}}
{{#if @first}}
      console.log('   ğŸ” Validating {{screenKey}}...');
      
{{#if pomClassName}}
      const {{pascalCase screenKey}}Screen = require('{{{../actionDetails.imports.[0].relativePath}}}');
      const {{screenKey}} = new {{pascalCase screenKey}}Screen(ctx.data.lang || 'en');
{{else}}
{{#if ../actionDetails.imports.[0]}}
      const {{screenKey}} = new {{../actionDetails.imports.[0].className}}(ctx.data.lang || 'en');
{{/if}}
{{/if}}
      
      await ExpectImplication.validateImplications(
        {{../implClassName}}.mirrorsOn.UI.{{platformKey}}.{{screenKey}},
        result.data,
        {{screenKey}}
      );
      console.log('   âœ… {{screenKey}} validation passed');
{{else}}
      // â­ï¸ TODO: Add validation for {{screenKey}}
{{/if}}
{{/each}}
      
result.save(testDataPath);
      console.log('   ğŸ’¾ State saved to:', testDataPath);
{{/if}}
      testPassed = true;
    });
  });
{{/if}}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

module.exports = { {{actionName}} };
