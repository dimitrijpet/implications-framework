// Auto-generated by Implications Framework
// Location: {{outputPath}}

/**
 * TestContext - Manages test data and state transitions
 * 
 * This class handles:
 * - Loading test data from JSON files (master or delta)
 * - Automatic delta file creation/management
 * - Entity-scoped state resolution
 * - Providing config for actions (device, lang, etc.)
 * - Tracking state changes (delta)
 * - Validating prerequisites
 * - Saving updated state to delta file (NEVER overwrites master)
 * 
 * FILE STRATEGY:
 * - Master files: *-master.json (read-only, pristine)
 * - Delta files: *-current.json (created automatically, tracks changes)
 * 
 * When you load "flight-booking-master.json":
 * - Checks if "flight-booking-current.json" exists
 * - If yes: loads from current (delta)
 * - If no: loads from master, will save to current
 * - Master file is NEVER modified
 */
class TestContext {
  constructor(ImplicationClass, testData, actualFilePath) {
    this.ImplicationClass = ImplicationClass;
    this.data = testData;
    this.changeLog = [];
    this.actualFilePath = actualFilePath;
    
    this.config = {
      device: testData.device || testData._config?.device || 'desktop',
      lang: testData.lang || testData._config?.lang || 'en',
      carrier: testData.carrier || testData._config?.carrier || 'LCC',
      debugMode: testData.debugMode || testData._config?.debugMode || false,
      baseURL: testData._config?.baseURL,
      ...testData._config
    };
    
    this.wrappers = {};
    this.bookingData = {};
    this.flightData = {};
    
    this.runtime = {
      price: null,
      indexStart: 0,
      orderId: null
    };
  }
  
  static getDeltaPath(inputPath) {
    if (inputPath.includes('-master.')) {
      return inputPath.replace('-master.', '-current.');
    }
    if (inputPath.includes('-current.')) {
      return inputPath;
    }
    return inputPath.replace('.json', '-current.json');
  }
  
  /**
   * ‚úÖ ENHANCED: Load test data with entity-scoped state resolution
   */
  static load(ImplicationClass, testDataPath) {
    const fs = require('fs');
    const path = require('path');
    
    let actualPath = testDataPath;
    let isMasterFile = testDataPath.includes('-master.');
    
    // ‚úÖ Check for -current.json
    if (!isMasterFile) {
      const baseName = path.basename(testDataPath, '.json');
      const dirName = path.dirname(testDataPath);
      const currentPath = path.join(dirName, `${baseName}-current.json`);
      
      if (fs.existsSync(currentPath)) {
        actualPath = currentPath;
        console.log(`   üìÇ Loading from delta file: ${path.basename(currentPath)}`);
      } else {
        console.log(`   üìÇ Loading from: ${path.basename(testDataPath)}`);
      }
    }
    
    const fileContents = fs.readFileSync(actualPath, 'utf8');
    const data = JSON.parse(fileContents);
    
    // Apply changeLog if present
    if (data._changeLog && data._changeLog.length > 0) {
      const original = data._original || {};
      let current = { ...original };
      
      for (const change of data._changeLog) {
        Object.assign(current, change.delta);
      }
      
      Object.assign(data, current);
      console.log(`   üìä Applied ${data._changeLog.length} changes from history`);
      console.log(`   üéØ Current state: ${data.status}`);
    } else {
      console.log(`   ‚ú® Fresh state loaded`);
    }
    
    // ‚úÖ‚úÖ‚úÖ NEW: Resolve entity-scoped status ‚úÖ‚úÖ‚úÖ
    const meta = ImplicationClass.xstateConfig?.meta || ImplicationClass.meta;
    
    if (meta?.entity) {
      const entity = meta.entity;
      console.log(`   üîç Entity-scoped implication: ${entity}`);
      
      // Try to find entity status in multiple places
      const entityData = data[entity] || {};
      const entityStatus = entityData.status ||
                          data[`${entity}.status`] ||
                          null;
      
      if (entityStatus) {
        console.log(`   ‚úÖ Found entity status: ${entity}.status = ${entityStatus}`);
        // Store for TestPlanner
        data._entityStatus = entityStatus;
        data._entity = entity;
      } else {
        console.log(`   ‚ö†Ô∏è  Entity ${entity} has no status field`);
      }
    }
    
    return new TestContext(ImplicationClass, data, testDataPath);
  }
  
  save(testDataPath) {
    const fs = require('fs');
    const path = require('path');
    
    let savePath;
    
    if (testDataPath) {
      savePath = TestContext.getDeltaPath(testDataPath);
    } else if (this.inputPath) {
      savePath = TestContext.getDeltaPath(this.inputPath);
    } else {
      savePath = this.actualFilePath;
    }
    
    const originalData = { ...this.data };
    
    for (let i = this.changeLog.length - 1; i >= 0; i--) {
      const change = this.changeLog[i];
      for (const key of Object.keys(change.delta)) {
        delete originalData[key];
      }
    }
    
    const masterPath = this.inputPath || testDataPath;
    if (masterPath && masterPath.includes('-master.') && fs.existsSync(masterPath)) {
      const masterData = JSON.parse(fs.readFileSync(masterPath, 'utf8'));
      Object.assign(originalData, masterData);
    }
    
    const output = {
      _original: originalData,
      _changeLog: this.changeLog
    };
    
    fs.writeFileSync(savePath, JSON.stringify(output, null, 2));
    
    const fileName = path.basename(savePath);
    const isMaster = savePath.includes('-master.');
    
    if (isMaster) {
      console.log(`   ‚ö†Ô∏è  WARNING: Saved to master file: ${fileName}`);
    } else {
      console.log(`   üíæ Saved to delta file: ${fileName}`);
    }
  }
  
  getBooking(index) {
    if (!this.data.bookings || !this.data.bookings[index]) {
      throw new Error(`Booking at index ${index} not found`);
    }
    return this.data.bookings[index];
  }
  
  getBookingsByStatus(status) {
    if (!this.data.bookings) return [];
    return this.data.bookings.filter(b => b.status === status);
  }
  
  getBookingsByIndices(indices) {
    if (!this.data.bookings) return [];
    return indices.map(i => this.getBooking(i));
  }
  
  applyDelta(path, value) {
    if (path.includes('[')) {
      const match = path.match(/^(\w+)\[(\d+)\]\.?(.*)$/);
      if (match) {
        const [, arrayName, index, rest] = match;
        if (!this.data[arrayName]) this.data[arrayName] = [];
        if (!this.data[arrayName][index]) this.data[arrayName][index] = {};
        if (rest) {
          this.data[arrayName][index][rest] = value;
        } else {
          this.data[arrayName][index] = { ...this.data[arrayName][index], ...value };
        }
      }
    } else {
      this.data[path] = value;
    }
  }
  
  getFromArray(arrayName, index) {
    if (!this.data[arrayName]) {
      console.warn(`‚ö†Ô∏è  Array '${arrayName}' does not exist`);
      return null;
    }
    return this.data[arrayName][index] || null;
  }
  
  setInArray(arrayName, index, value) {
    if (!this.data[arrayName]) {
      this.data[arrayName] = [];
    }
    this.data[arrayName][index] = value;
  }
  
  pushToArray(arrayName, value) {
    if (!this.data[arrayName]) {
      this.data[arrayName] = [];
    }
    this.data[arrayName].push(value);
    return this.data[arrayName].length - 1;
  }
  
  removeFromArray(arrayName, index) {
    if (!this.data[arrayName]) {
      console.warn(`‚ö†Ô∏è  Array '${arrayName}' does not exist`);
      return;
    }
    this.data[arrayName].splice(index, 1);
  }

  /**
   * ‚úÖ Get nested value from object
   * Supports paths like 'dancer.email' or 'email'
   */
  static getNestedValue(obj, path) {
    if (!path.includes('.')) {
      return obj[path];
    }
    
    const parts = path.split('.');
    let current = obj;
    
    for (const part of parts) {
      if (!current || !current.hasOwnProperty(part)) {
        return undefined;
      }
      current = current[part];
    }
    
    return current;
  }
  
  /**
   * ‚úÖ Set nested value in object
   * Supports paths like 'dancer.email' or 'email'
   */
  static setNestedValue(obj, path, value) {
    if (!path.includes('.')) {
      obj[path] = value;
      return;
    }
    
    const parts = path.split('.');
    let current = obj;
    
    for (let i = 0; i < parts.length - 1; i++) {
      if (!current[parts[i]]) {
        current[parts[i]] = {};
      }
      current = current[parts[i]];
    }
    
    current[parts[parts.length - 1]] = value;
  }
  
  /**
   * ‚úÖ ENHANCED: Execute action and save with nested path support
   */
  async executeAndSave(label, testFile, deltaFn) {
    const { delta } = await deltaFn();
    
    // ‚úÖ Apply delta with nested path support to this.data
    for (const [key, value] of Object.entries(delta)) {
      if (key.includes('.')) {
        const parts = key.split('.');
        let obj = this.data;
        for (let i = 0; i < parts.length - 1; i++) {
          if (!obj[parts[i]]) obj[parts[i]] = {};
          obj = obj[parts[i]];
        }
        obj[parts[parts.length - 1]] = value;
      } else {
        this.data[key] = value;
      }
    }
    
    // ‚úÖ Save to changeLog
    this.changeLog.push({
      label,
      testFile,
      delta,
      timestamp: new Date().toISOString()
    });
    
    return this;
  }
}

module.exports = TestContext;
