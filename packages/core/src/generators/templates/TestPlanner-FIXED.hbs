// Auto-generated by Implications Framework
// Location: {{outputPath}}
{{#if timestamp}}// Generated: {{timestamp}}{{/if}}

const fs = require('fs');
const path = require('path');

/**
 * TestPlanner - Validates prerequisites and auto-executes chains
 * 
 * This class handles:
 * - Building prerequisite chains from XState transitions
 * - Checking if test data is in correct state
 * - Validating required fields exist
 * - Finding the path from current state to target state
 * - AUTO-EXECUTING prerequisites in UNIT tests
 * - Providing helpful errors with exact commands to run
 */
class TestPlanner {
  
  constructor(options = {}) {
    this.options = {
      verbose: options.verbose ?? true,
      config: options.config || null,
      stateRegistry: options.stateRegistry || null
    };
    
    // Try to load state registry if not provided
    if (!this.stateRegistry) {
      this.stateRegistry = this.loadStateRegistry();
    }
  }
  
  /**
   * Load .state-registry.json from the implications directory
   * Maps state names to Implication class names
   */
  loadStateRegistry() {
    try {
      const possiblePaths = [
        path.join(process.cwd(), 'tests/implications/bookings/status/.state-registry.json'),
        path.join(process.cwd(), 'tests/implications/.state-registry.json'),
        path.join(process.cwd(), 'tests/ai-testing/implications/.state-registry.json'),
        path.join(__dirname, '../implications/.state-registry.json'),
        path.join(__dirname, '../../implications/.state-registry.json'),
        path.join(__dirname, '../../implications/bookings/status/.state-registry.json')
      ];
      
      for (const registryPath of possiblePaths) {
        if (fs.existsSync(registryPath)) {
          const registry = JSON.parse(fs.readFileSync(registryPath, 'utf8'));
          if (this.options.verbose) {
            console.log(`üìã Loaded state registry: ${registryPath}`);
          }
          return registry;
        }
      }
      
      if (this.options.verbose) {
        console.log('‚ö†Ô∏è  No state registry found - limited chain building');
      }
      return {};
      
    } catch (error) {
      if (this.options.verbose) {
        console.log('‚ö†Ô∏è  Error loading state registry:', error.message);
      }
      return {};
    }
  }
  
  /**
   * Analyze if test can run and build prerequisite chain
   */
  analyze(ImplicationClass, testData, options = {}) {
    const xstateConfig = ImplicationClass.xstateConfig || {};
    const meta = xstateConfig.meta || {};
    
    const targetStatus = meta.status;
    const currentStatus = testData.status || 'unknown';
    
    if (this.options.verbose) {
      console.log(`\nüîç TestPlanner: Analyzing ${targetStatus} state`);
      console.log(`   Current: ${currentStatus}`);
      console.log(`   Target: ${targetStatus}`);
    }
    
    // Build the prerequisite chain
    const chain = this.buildPrerequisiteChain(ImplicationClass, currentStatus, targetStatus);
    
    // Check if we're ready
    const ready = this.isReady(chain, currentStatus);
    
    // Find next step if not ready
    const nextStep = ready ? null : this.findNextStep(chain, currentStatus);
    
    // Count remaining steps
    const stepsRemaining = chain.filter(step => !step.complete).length;
    
    // Find missing fields
    const missingFields = this.findMissingFields(meta, testData);
    
    const analysis = {
      ready: ready && missingFields.length === 0,
      currentStatus,
      targetStatus,
      missingFields,
      chain,
      nextStep,
      stepsRemaining
    };
    
    if (this.options.verbose) {
      console.log(`   Ready: ${analysis.ready ? '‚úÖ' : '‚ùå'}`);
      if (!analysis.ready) {
        console.log(`   Missing steps: ${stepsRemaining}`);
        if (missingFields.length > 0) {
          console.log(`   Missing fields: ${missingFields.join(', ')}`);
        }
      }
    }
    
    return analysis;
  }
  
  /**
   * Build the chain of prerequisites from current state to target state
   */
  buildPrerequisiteChain(ImplicationClass, currentStatus, targetStatus) {
    const chain = [];
    const xstateConfig = ImplicationClass.xstateConfig || {};
    const meta = xstateConfig.meta || {};
    
    // Target step
    const targetStep = {
      status: targetStatus,
      actionName: meta.setup?.[0]?.actionName || 'unknown',
      testFile: meta.setup?.[0]?.testFile || 'unknown',
      platform: meta.platform || 'unknown',
      complete: currentStatus === targetStatus,
      isCurrent: currentStatus === targetStatus,
      isTarget: true
    };
    
    // Check for previous status
    if (meta.requires?.previousStatus) {
      const previousStatus = meta.requires.previousStatus;
      
      // Look up in state registry
      const prevImplClassName = this.stateRegistry[previousStatus];
      
      let prevStep = {
        status: previousStatus,
        actionName: 'unknown',
        testFile: 'unknown',
        platform: 'unknown',
        complete: currentStatus === previousStatus,
        isCurrent: currentStatus === previousStatus,
        isTarget: false
      };
      
      if (prevImplClassName) {
        try {
          // Load the prerequisite Implication class
          const prevImplPath = path.join(
            path.dirname(require.resolve('./TestPlanner.js')),
            '../../implications/bookings/status',
            `${prevImplClassName}.js`
          );
          
          const PrevImplClass = require(prevImplPath);
          const prevMeta = PrevImplClass.xstateConfig?.meta || {};
          
          // Extract the info
          prevStep.actionName = prevMeta.setup?.[0]?.actionName || 'unknown';
          prevStep.testFile = prevMeta.setup?.[0]?.testFile || 'unknown';
          prevStep.platform = prevMeta.platform || 'unknown';
          
          console.log(`   ‚úÖ Loaded prerequisite: ${prevImplClassName}`);
          console.log(`      Action: ${prevStep.actionName}`);
          console.log(`      Test: ${prevStep.testFile}`);
        } catch (error) {
          console.log(`   ‚ö†Ô∏è  Could not load ${prevImplClassName}: ${error.message}`);
        }
      }
      
      chain.push(prevStep);
    }
    
    chain.push(targetStep);
    
    // Generate commands
    chain.forEach(step => {
      if (step.testFile && step.testFile !== 'unknown') {
        const testDataPath = this.options.config?.testDataPath || 'tests/data/shared.json';
        const command = `TEST_DATA_PATH="${testDataPath}" npx playwright test tests/implications/bookings/status/${step.testFile}`;
        step.command = command;
      }
    });
    
    return chain;
  }
  
  /**
   * Check if test is ready to run
   */
  isReady(chain, currentStatus) {
    const incompleteSteps = chain.filter(step => !step.complete);
    
    // If there are no incomplete steps, we're ready
    if (incompleteSteps.length === 0) {
      return true;
    }
    
    // If the only incomplete step is the target, we're ready
    if (incompleteSteps.length === 1 && incompleteSteps[0].isTarget) {
      return true;
    }
    
    return false;
  }
  
  /**
   * Find the next step to execute
   */
  findNextStep(chain, currentStatus) {
    // Find the first incomplete non-target step
    const nextStep = chain.find(step => !step.complete && !step.isTarget);
    
    if (nextStep) {
      return {
        ...nextStep,
        executable: true,
        executor: {
          type: 'shell',
          cwd: process.cwd(),
          env: { TEST_DATA_PATH: this.options.config?.testDataPath || 'tests/data/shared.json' }
        }
      };
    }
    
    return null;
  }
  
  /**
   * Find missing required fields
   */
  findMissingFields(meta, testData) {
    const missing = [];
    
    if (meta.requiredFields && meta.requiredFields.length > 0) {
      for (const field of meta.requiredFields) {
        if (!testData.hasOwnProperty(field) || testData[field] === null || testData[field] === undefined) {
          missing.push(field);
        }
      }
    }
    
    return missing;
  }
  
  /**
   * Print a helpful error message when prerequisites not met
   */
  printNotReadyError(analysis) {
    const { currentStatus, targetStatus, chain, nextStep, missingFields, stepsRemaining } = analysis;
    
    console.error('\n' + '‚ïê'.repeat(60));
    console.error('‚ùå TEST NOT READY - PREREQUISITES NOT MET');
    console.error('‚ïê'.repeat(60));
    
    console.error(`\nüìä Status:`);
    console.error(`   Current: ${currentStatus}`);
    console.error(`   Target:  ${targetStatus}`);
    
    if (missingFields.length > 0) {
      console.error(`\n‚ùå Missing Required Fields:`);
      missingFields.forEach(field => {
        console.error(`   - ${field}`);
      });
    }
    
    console.error(`\nüó∫Ô∏è  Full Path to Target:\n`);
    
    chain.forEach((step, index) => {
      const icon = step.complete ? '‚úÖ' : step.isTarget ? 'üéØ' : 'üìç';
      const label = step.complete ? 'You are here' : step.isTarget ? 'Target' : '';
      
      console.error(`   ${icon} ${index + 1}. ${step.status}${label ? ' ‚Üê ' + label : ''}`);
      
      if (!step.complete && !step.isTarget) {
        console.error(`      Action: ${step.actionName}`);
        console.error(`      Test: ${step.testFile}`);
        console.error(`      Platform: ${step.platform}`);
      }
      
      if (index < chain.length - 1) {
        console.error('      ‚Üì');
      }
    });
    
    if (nextStep) {
      console.error(`\nüí° NEXT STEP TO TAKE:\n`);
      console.error(`   Status: ${nextStep.status}`);
      console.error(`   Action: ${nextStep.actionName}`);
      console.error(`   Platform: ${nextStep.platform}`);
      console.error(`   `);
      console.error(`   Command:`);
      console.error(`   ${nextStep.command}`);
      console.error(`   `);
      
      if (stepsRemaining > 1) {
        console.error(`   ‚è≠Ô∏è  ${stepsRemaining - 1} more step(s) after this\n`);
      }
    }
    
    console.error('‚ïê'.repeat(60) + '\n');
  }
  
  /**
   * Check if prerequisites are met, auto-execute if not (UNIT tests only)
   * 
   * This is the main entry point used in generated UNIT tests
   * 
   * @param {class} ImplicationClass - The Implication class
   * @param {object} testData - Current test data
   * @param {object} options - Options (page, testDataPath)
   */
  static async checkOrThrow(ImplicationClass, testData, options = {}) {
    const planner = new TestPlanner({ 
      verbose: options.verbose ?? true,
      config: options.config
    });
    
    const analysis = planner.analyze(ImplicationClass, testData, options);
    
    // ‚úÖ CHECK: Already in target state? Skip everything!
    const targetStatus = ImplicationClass.xstateConfig?.meta?.status;
    const currentStatus = testData.status;
    
    if (targetStatus && currentStatus === targetStatus) {
      console.log(`‚úÖ Already in target state (${targetStatus}), no action needed\n`);
      return { ready: true, skipped: true, currentStatus, targetStatus };
    }
    
    // If not ready and we have a next step, auto-execute it
    if (!analysis.ready && analysis.nextStep && options.page) {
      const { testFile, actionName } = analysis.nextStep;
      
      console.log(`\n‚ö° Auto-executing prerequisite: ${actionName}\n`);
      
      try {
        // Set env to skip test registration
        process.env.SKIP_UNIT_TEST_REGISTRATION = 'true';
        
        // Dynamically require the UNIT test
        const testPath = path.join(
          process.cwd(), 
          'tests/implications/bookings/status',
          testFile
        );
        
        const testModule = require(testPath);
        delete process.env.SKIP_UNIT_TEST_REGISTRATION;
        
        const triggerFn = testModule[actionName];
        
        if (!triggerFn) {
          throw new Error(`Function ${actionName} not exported from ${testFile}`);
        }
        
        // Determine testDataPath
        const testDataPath = options.testDataPath 
          || testData.__testDataPath 
          || process.env.TEST_DATA_PATH 
          || 'tests/data/shared.json';
        
        // Execute the prerequisite (it handles its own smart navigation)
        const result = await triggerFn(testDataPath, {
          page: options.page,
          testDataPath
        });
        
        // ‚úÖ CRITICAL: Save to disk before reloading
        if (result && result.save) {
          result.save(testDataPath);
          console.log('   üíæ Prerequisite state saved');
        }
        
        // ‚úÖ Reload test data after prerequisite ran using TestContext
        const TestContext = require('./TestContext');
        const reloadedCtx = TestContext.load(ImplicationClass, testDataPath);
        
        // ‚úÖ Update the original testData object with reloaded data
        Object.assign(testData, reloadedCtx.data);
        
        // Re-check with UPDATED data
        const newAnalysis = planner.analyze(ImplicationClass, reloadedCtx.data);
        
        if (!newAnalysis.ready) {
          // Still not ready? Go deeper (recursive for multi-level chains)
          return TestPlanner.checkOrThrow(ImplicationClass, reloadedCtx.data, options);
        }
        
        console.log('‚úÖ Prerequisites satisfied!\n');
        return newAnalysis;
        
      } catch (error) {
        console.error(`‚ùå Failed to auto-execute prerequisite: ${error.message}\n`);
        delete process.env.SKIP_UNIT_TEST_REGISTRATION;
        planner.printNotReadyError(analysis);
        throw error;
      }
    }
    
    // If not ready and no auto-execute option, just throw
    if (!analysis.ready) {
      planner.printNotReadyError(analysis);
      throw new Error('Prerequisites not met');
    }
    
    return analysis;
  }
}

module.exports = TestPlanner;
