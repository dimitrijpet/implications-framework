// Auto-generated by Implications Framework
// Location: {{outputPath}}
{{#if timestamp}}// Generated: {{timestamp}}{{/if}}

const fs = require('fs');
const path = require('path');

/**
 * TestPlanner - Validates prerequisites and auto-executes chains
 * 
 * RECURSIVE PREREQUISITE CHAINING:
 * - Builds full chain from current state to target
 * - Auto-executes missing steps in UNIT tests
 * - Supports multi-level chains (A â†’ B â†’ C â†’ D)
 * - Reloads data after each step
 * - Prevents infinite loops
 */
class TestPlanner {
  
  constructor(options = {}) {
    this.options = {
      verbose: options.verbose ?? true,
      config: options.config || null,
      stateRegistry: options.stateRegistry || null
    };
    
    if (!this.stateRegistry) {
      this.stateRegistry = this.loadStateRegistry();
    }
  }
  
  loadStateRegistry() {
  try {
    // âœ… Use canonical registry path
    const REGISTRY_PATH = path.join(process.cwd(), 'tests/implications/.state-registry.json');
    const possiblePaths = [REGISTRY_PATH];
    
    for (const registryPath of possiblePaths) {
        if (fs.existsSync(registryPath)) {
          const registry = JSON.parse(fs.readFileSync(registryPath, 'utf8'));
          if (this.options.verbose) {
            console.log(`ğŸ“‹ Loaded state registry: ${registryPath}`);
          }
          return registry;
        }
      }
      
      if (this.options.verbose) {
        console.log('âš ï¸  No state registry found');
      }
      return {};
      
    } catch (error) {
      if (this.options.verbose) {
        console.log('âš ï¸  Error loading state registry:', error.message);
      }
      return {};
    }
  }
  
  analyze(ImplicationClass, testData, options = {}) {
    const xstateConfig = ImplicationClass.xstateConfig || {};
    const meta = xstateConfig.meta || {};
    
    const targetStatus = meta.status;
    const currentStatus = testData.status || 'unknown';
    
    if (this.options.verbose) {
      console.log(`\nğŸ” TestPlanner: Analyzing ${targetStatus} state`);
      console.log(`   Current: ${currentStatus}`);
      console.log(`   Target: ${targetStatus}`);
    }
    
    const chain = this.buildPrerequisiteChain(ImplicationClass, currentStatus, targetStatus);
    const ready = this.isReady(chain, currentStatus);
    const nextStep = ready ? null : this.findNextStep(chain, currentStatus);
    const stepsRemaining = chain.filter(step => !step.complete).length;
    const missingFields = this.findMissingFields(meta, testData);
    
    const analysis = {
      ready: ready && missingFields.length === 0,
      currentStatus,
      targetStatus,
      missingFields,
      chain,
      nextStep,
      stepsRemaining
    };
    
    if (this.options.verbose) {
      console.log(`   Ready: ${analysis.ready ? 'âœ…' : 'âŒ'}`);
      if (!analysis.ready) {
        console.log(`   Missing steps: ${stepsRemaining}`);
        if (missingFields.length > 0) {
          console.log(`   Missing fields: ${missingFields.join(', ')}`);
        }
      }
    }
    
    return analysis;
  }
  
  buildPrerequisiteChain(ImplicationClass, currentStatus, targetStatus, visited = new Set()) {
    const chain = [];
    
    if (visited.has(targetStatus)) {
      console.warn(`âš ï¸  Circular dependency detected for ${targetStatus}`);
      return chain;
    }
    
    visited.add(targetStatus);
    
    const xstateConfig = ImplicationClass.xstateConfig || {};
    const meta = xstateConfig.meta || {};
    
    if (meta.requires?.previousStatus) {
      const previousStatus = meta.requires.previousStatus;
      const prevImplClassName = this.stateRegistry[previousStatus];
      
      if (prevImplClassName && !visited.has(previousStatus)) {
        try {
          const prevImplPath = this.findImplicationFile(prevImplClassName);
          if (prevImplPath) {
            const PrevImplClass = require(prevImplPath);
            const prevChain = this.buildPrerequisiteChain(PrevImplClass, currentStatus, previousStatus, visited);
            chain.push(...prevChain);
          }
        } catch (error) {
          console.log(`   âš ï¸  Could not load ${prevImplClassName}: ${error.message}`);
        }
      }
    }
    
    chain.push({
      status: targetStatus,
      className: ImplicationClass.name,
      actionName: meta.setup?.[0]?.actionName || 'unknown',
      testFile: meta.setup?.[0]?.testFile || 'unknown',
      platform: meta.platform || 'unknown',
      complete: currentStatus === targetStatus,
      isCurrent: currentStatus === targetStatus,
      isTarget: true
    });
    
    return chain;
  }
  
  findImplicationFile(className) {
    const searchPaths = [
      path.join(process.cwd(), 'tests/implications'),
      path.join(process.cwd(), 'tests/ai-testing/implications'),
      path.join(__dirname, '..')
    ];
    
    for (const basePath of searchPaths) {
      const patterns = [
        path.join(basePath, `${className}.js`),
        path.join(basePath, '**', `${className}.js`)
      ];
      
      for (const pattern of patterns) {
        if (fs.existsSync(pattern)) {
          return pattern;
        }
      }
      
      if (fs.existsSync(basePath)) {
        const files = this.findFilesRecursive(basePath, `${className}.js`);
        if (files.length > 0) {
          return files[0];
        }
      }
    }
    
    return null;
  }
  
  findFilesRecursive(dir, filename) {
    const results = [];
    
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const item of items) {
        const fullPath = path.join(dir, item.name);
        
        if (item.isDirectory()) {
          results.push(...this.findFilesRecursive(fullPath, filename));
        } else if (item.name === filename) {
          results.push(fullPath);
        }
      }
    } catch (error) {
      // Skip directories we can't read
    }
    
    return results;
  }
  
  isReady(chain, currentStatus) {
    const incompleteSteps = chain.filter(step => !step.complete);
    
    if (incompleteSteps.length === 0) {
      return true;
    }
    
    if (incompleteSteps.length === 1 && incompleteSteps[0].isTarget) {
      return true;
    }
    
    return false;
  }
  
  findNextStep(chain, currentStatus) {
    const nextStep = chain.find(step => !step.complete && !step.isTarget);
    
    if (nextStep) {
      return {
        ...nextStep,
        executable: true
      };
    }
    
    return null;
  }
  
  findMissingFields(meta, testData) {
    const missing = [];
    
    if (meta.requiredFields && meta.requiredFields.length > 0) {
      for (const field of meta.requiredFields) {
        if (!testData.hasOwnProperty(field) || testData[field] === null || testData[field] === undefined) {
          missing.push(field);
        }
      }
    }
    
    return missing;
  }
  
  printNotReadyError(analysis) {
    const { currentStatus, targetStatus, chain, nextStep, missingFields } = analysis;
    
    console.error('\n' + 'â•'.repeat(60));
    console.error('âŒ TEST NOT READY - PREREQUISITES NOT MET');
    console.error('â•'.repeat(60));
    
    console.error(`\nğŸ“Š Status:`);
    console.error(`   Current: ${currentStatus}`);
    console.error(`   Target:  ${targetStatus}`);
    
    if (missingFields.length > 0) {
      console.error(`\nâŒ Missing Required Fields:`);
      missingFields.forEach(field => {
        console.error(`   - ${field}`);
      });
    }
    
    console.error(`\nğŸ—ºï¸  Full Path to Target:\n`);
    
    chain.forEach((step, index) => {
      const icon = step.complete ? 'âœ…' : step.isTarget ? 'ğŸ¯' : 'ğŸ“';
      const label = step.complete ? ' â† You are here' : step.isTarget ? ' â† Target' : '';
      
      console.error(`   ${icon} ${index + 1}. ${step.status}${label}`);
      
      if (!step.complete && !step.isTarget) {
        console.error(`      Action: ${step.actionName}`);
        console.error(`      Test: ${step.testFile}`);
      }
      
      if (index < chain.length - 1) {
        console.error('      â†“');
      }
    });
    
    if (nextStep) {
      console.error(`\nğŸ’¡ NEXT STEP: ${nextStep.status}`);
      console.error(`   Action: ${nextStep.actionName}`);
      console.error(`   Test: ${nextStep.testFile}`);
    }
    
    console.error('â•'.repeat(60) + '\n');
  }
  
  /**
   * âœ… RECURSIVE checkOrThrow - The magic happens here
   */
  static async checkOrThrow(ImplicationClass, testData, options = {}) {
    const planner = new TestPlanner({ 
      verbose: options.verbose ?? true,
      config: options.config
    });
    
    const analysis = planner.analyze(ImplicationClass, testData, options);
    
    const targetStatus = ImplicationClass.xstateConfig?.meta?.status;
    const currentStatus = testData.status;
    
    if (targetStatus && currentStatus === targetStatus) {
      console.log(`âœ… Already in target state (${targetStatus}), no action needed\n`);
      return { ready: true, skipped: true, currentStatus, targetStatus };
    }
    
    if (!analysis.ready && analysis.nextStep && options.page) {
      const { testFile, actionName } = analysis.nextStep;
      
      console.log(`\nâš¡ Auto-executing prerequisite: ${actionName}\n`);
      
      try {
        process.env.SKIP_UNIT_TEST_REGISTRATION = 'true';
        
        const testPath = path.join(
          process.cwd(), 
          'tests/implications',
          testFile
        );
        
        const testModule = require(testPath);
        delete process.env.SKIP_UNIT_TEST_REGISTRATION;
        
        const triggerFn = testModule[actionName];
        
        if (!triggerFn) {
          throw new Error(`Function ${actionName} not exported from ${testFile}`);
        }
        
        const testDataPath = options.testDataPath 
          || testData.__testDataPath 
          || process.env.TEST_DATA_PATH 
          || 'tests/data/shared.json';
        
        const result = await triggerFn(testDataPath, {
          page: options.page,
          testDataPath
        });
        
        if (result && result.save) {
          result.save(testDataPath);
          console.log('   ğŸ’¾ Prerequisite state saved');
        }
        
        const TestContext = require('./TestContext');
        const reloadedCtx = TestContext.load(ImplicationClass, testDataPath);
        Object.assign(testData, reloadedCtx.data);
        
        const newAnalysis = planner.analyze(ImplicationClass, reloadedCtx.data);
        
        if (!newAnalysis.ready) {
          // âœ… RECURSIVE CALL - Go deeper for multi-level chains
          return TestPlanner.checkOrThrow(ImplicationClass, reloadedCtx.data, options);
        }
        
        console.log('âœ… Prerequisites satisfied!\n');
        return newAnalysis;
        
      } catch (error) {
        console.error(`âŒ Failed to auto-execute prerequisite: ${error.message}\n`);
        delete process.env.SKIP_UNIT_TEST_REGISTRATION;
        planner.printNotReadyError(analysis);
        throw error;
      }
    }
    
    if (!analysis.ready) {
      planner.printNotReadyError(analysis);
      throw new Error('Prerequisites not met');
    }
    
    return analysis;
  }
}

module.exports = TestPlanner;