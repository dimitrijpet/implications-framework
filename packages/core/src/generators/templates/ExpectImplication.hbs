// Auto-generated by Implications Framework
// Location: {{outputPath}}
{{#if timestamp}}// Generated: {{timestamp}}{{/if}}

const { expect } = require('@playwright/test');

/**
 * ExpectImplication - Validates UI state against implications
 * 
 * This class handles:
 * - Executing prerequisites (navigation, setup)
 * - Validating visible elements
 * - Validating hidden elements  
 * - Checking text content with variable substitution
 * - Running custom expect functions
 * - Supporting both Playwright and Appium
 */
class ExpectImplication {
  /**
   * Main validation entry point
   * Validates all screens for a given implication
   */
  static async validateImplications(screenDef, testData, screenObject) {
    if (!screenDef || screenDef.length === 0) {
      console.log('   âš ï¸  No screen definition to validate');
      return;
    }
    
    // Handle both array and object formats
    const def = Array.isArray(screenDef) ? screenDef[0] : screenDef;
    
    console.log(`   ðŸ” Validating screen: ${def.name || 'unnamed'}`);
    
    // âœ… Execute prerequisites FIRST (navigation, setup, etc.)
    if (def.prerequisites && def.prerequisites.length > 0) {
      console.log(`   ðŸ”§ Running ${def.prerequisites.length} prerequisites...`);
      for (const prereq of def.prerequisites) {
        console.log(`      ${prereq.description}`);
        await prereq.setup(testData, page);
      }
      console.log('   âœ… Prerequisites completed');
    }
    
    // Validate visible elements (top-level)
    if (def.visible && def.visible.length > 0) {
      console.log(`   âœ… Checking ${def.visible.length} visible elements...`);
      for (const elementSelector of def.visible) {
        try {
          const element = page.locator(`[data-testid="${elementSelector}"]`);
          await expect(element).toBeVisible({ timeout: 10000 });
          console.log(`      âœ“ ${elementSelector} is visible`);
        } catch (error) {
          console.error(`      âœ— ${elementSelector} NOT visible: ${error.message}`);
          throw new Error(`Visibility check failed for ${elementSelector}`);
        }
      }
    }
    
    // Validate hidden elements (top-level)
    if (def.hidden && def.hidden.length > 0) {
      console.log(`   âœ… Checking ${def.hidden.length} hidden elements...`);
      for (const elementSelector of def.hidden) {
        try {
            const element = await this.getElement(screenObject, elementSelector);
          const count = await element.count();
          
          if (count === 0) {
            console.log(`      âœ“ ${elementSelector} doesn't exist (counts as hidden)`);
            continue;
          }
          
          await expect(element).not.toBeVisible();
          console.log(`      âœ“ ${elementSelector} is hidden`);
        } catch (error) {
          console.error(`      âœ— ${elementSelector} NOT hidden: ${error.message}`);
          throw new Error(`Hidden check failed for ${elementSelector}`);
        }
      }
    }
    
    // Validate checks (additional validations)
    if (def.checks) {
      console.log('   ðŸ” Running additional checks...');
      
      // checks.visible (extra visibility checks)
      if (def.checks.visible && def.checks.visible.length > 0) {
        console.log(`   âœ… Checking ${def.checks.visible.length} additional visible elements...`);
        for (const elementSelector of def.checks.visible) {
          try {
            const element = page.locator(`[data-testid="${elementSelector}"]`);
            await expect(element).toBeVisible({ timeout: 10000 });
            console.log(`      âœ“ ${elementSelector} is visible`);
          } catch (error) {
            console.error(`      âœ— ${elementSelector} NOT visible: ${error.message}`);
            throw new Error(`Checks.visible failed for ${elementSelector}`);
          }
        }
      }
      
      // checks.hidden (extra hidden checks)
      if (def.checks.hidden && def.checks.hidden.length > 0) {
        console.log(`   âœ… Checking ${def.checks.hidden.length} additional hidden elements...`);
        for (const elementSelector of def.checks.hidden) {
          try {
            const element = page.locator(`[data-testid="${elementSelector}"]`);
            const count = await element.count();
            
            if (count === 0) {
              console.log(`      âœ“ ${elementSelector} doesn't exist (counts as hidden)`);
              continue;
            }
            
            await expect(element).not.toBeVisible();
            console.log(`      âœ“ ${elementSelector} is hidden`);
          } catch (error) {
            console.error(`      âœ— ${elementSelector} NOT hidden: ${error.message}`);
            throw new Error(`Checks.hidden failed for ${elementSelector}`);
          }
        }
      }
      
      // checks.text (text content validation with variable substitution)
      if (def.checks.text && Object.keys(def.checks.text).length > 0) {
        console.log(`   âœ… Checking ${Object.keys(def.checks.text).length} text checks...`);
        for (const [elementSelector, expectedText] of Object.entries(def.checks.text)) {
          try {
            const element = page.locator(`[data-testid="${elementSelector}"]`);
            
            // Variable substitution: {{fieldName}} -> testData.fieldName
            let finalText = expectedText;
            if (typeof expectedText === 'string' && expectedText.includes('{{')) {
              const variableMatch = expectedText.match(/\{\{(\w+)\}\}/);
              if (variableMatch && testData && testData[variableMatch[1]]) {
                finalText = expectedText.replace(/\{\{(\w+)\}\}/, testData[variableMatch[1]]);
                console.log(`      ðŸ“ Substituted {{${variableMatch[1]}}} -> ${testData[variableMatch[1]]}`);
              }
            }
            
            await expect(element).toHaveText(finalText, { timeout: 10000 });
            console.log(`      âœ“ ${elementSelector} has text: "${finalText}"`);
          } catch (error) {
            console.error(`      âœ— ${elementSelector} text check failed: ${error.message}`);
            throw new Error(`Text check failed for ${elementSelector}`);
          }
        }
      }
    }
    
    // Run custom expect function if provided
    if (def.expect && typeof def.expect === 'function') {
      console.log('   ðŸŽ¯ Running custom expect function...');
      await def.expect(testData, page);
      console.log('   âœ… Custom expect passed');
    }
    
    console.log(`   âœ… All validations passed for ${def.name || 'screen'}`);
  }
  
  /**
   * Helper: Check if element is Playwright
   */
  static isPlaywright(element) {
    return element && typeof element.locator === 'function';
  }
}

module.exports = ExpectImplication;
