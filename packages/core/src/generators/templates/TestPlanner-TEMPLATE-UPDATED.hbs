// Auto-generated by Implications Framework
// Location: {{outputPath}}
{{#if timestamp}}// Generated: {{timestamp}}{{/if}}

const fs = require('fs');
const path = require('path');

/**
 * TestPlanner - Validates prerequisites and auto-executes chains
 * 
 * RECURSIVE PREREQUISITE CHAINING:
 * - Builds full chain from current state to target
 * - Auto-executes missing steps in UNIT tests
 * - Supports multi-level chains (A â†’ B â†’ C â†’ D)
 * - Reloads data after each step
 * - Prevents infinite loops
 * 
 * BLOCKING SUPPORT:
 * - Validates array containment (blocked_clubs, blocked_dancers)
 * - Supports negation (!field)
 * - Resolves value references (ctx.data.club.name)
 * - Separates entity fields from regular fields
 */
class TestPlanner {
  
  constructor(options = {}) {
    this.options = {
      verbose: options.verbose ?? true,
      config: options.config || null,
      stateRegistry: options.stateRegistry || null
    };
    
    if (!this.stateRegistry) {
      this.stateRegistry = this.loadStateRegistry();
    }
  }
  
  loadStateRegistry() {
    try {
      const REGISTRY_PATH = path.join(process.cwd(), 'tests/implications/.state-registry.json');
      
      if (fs.existsSync(REGISTRY_PATH)) {
        const registry = JSON.parse(fs.readFileSync(REGISTRY_PATH, 'utf8'));
        if (this.options.verbose) {
          console.log(`ğŸ“‹ Loaded state registry: ${REGISTRY_PATH}`);
        }
        return registry;
      }
      
      if (this.options.verbose) {
        console.log('âš ï¸  No state registry found');
      }
      return {};
      
    } catch (error) {
      if (this.options.verbose) {
        console.log('âš ï¸  Error loading state registry:', error.message);
      }
      return {};
    }
  }
  
  analyze(ImplicationClass, testData, options = {}) {
    const xstateConfig = ImplicationClass.xstateConfig || {};
    const meta = xstateConfig.meta || {};
    
    const targetStatus = meta.status;
    const currentStatus = testData.status || 'unknown';
    
    if (this.options.verbose) {
      console.log(`\nğŸ” TestPlanner: Analyzing ${targetStatus} state`);
      console.log(`   Current: ${currentStatus}`);
      console.log(`   Target: ${targetStatus}`);
    }
    
    const chain = this.buildPrerequisiteChain(ImplicationClass, currentStatus, targetStatus);
    const missingFields = this.findMissingFields(meta, testData);
    
    // âœ… Separate entity fields (auto-resolvable) from regular fields (must pass)
    const entityFields = missingFields.filter(f => {
      const fieldName = typeof f === 'string' ? f : f.field;
      return fieldName && fieldName.includes('.status');
    });
    
    const regularFields = missingFields.filter(f => {
      const fieldName = typeof f === 'string' ? f : f.field;
      return fieldName && !fieldName.includes('.status');
    });
    
    const ready = this.isReady(chain, currentStatus) && regularFields.length === 0;
    const nextStep = ready ? null : this.findNextStep(chain, currentStatus);
    const stepsRemaining = chain.filter(step => !step.complete).length;
    
    const analysis = {
      ready,
      currentStatus,
      targetStatus,
      missingFields,
      entityFields,
      regularFields,
      chain,
      nextStep,
      stepsRemaining
    };
    
    if (this.options.verbose) {
      console.log(`   Ready: ${analysis.ready ? 'âœ…' : 'âŒ'}`);
      if (!analysis.ready) {
        console.log(`   Missing steps: ${stepsRemaining}`);
        if (regularFields.length > 0) {
          console.log(`   Missing fields: ${regularFields.map(f => typeof f === 'string' ? f : f.field).join(', ')}`);
        }
        if (entityFields.length > 0) {
          console.log(`   Entity requirements (auto-resolvable): ${entityFields.map(f => typeof f === 'string' ? f : f.field).join(', ')}`);
        }
      }
    }
    
    return analysis;
  }
  
  buildPrerequisiteChain(ImplicationClass, currentStatus, targetStatus, visited = new Set()) {
    const chain = [];
    
    if (visited.has(targetStatus)) {
      console.warn(`âš ï¸  Circular dependency detected for ${targetStatus}`);
      return chain;
    }
    
    visited.add(targetStatus);
    
    const xstateConfig = ImplicationClass.xstateConfig || {};
    const meta = xstateConfig.meta || {};
    
    if (meta.requires?.previousStatus) {
      const previousStatus = meta.requires.previousStatus;
      const prevImplClassName = this.stateRegistry[previousStatus];
      
      if (prevImplClassName && !visited.has(previousStatus)) {
        try {
          const prevImplPath = this.findImplicationFile(prevImplClassName);
          if (prevImplPath) {
            const PrevImplClass = require(prevImplPath);
            const prevChain = this.buildPrerequisiteChain(PrevImplClass, currentStatus, previousStatus, visited);
            chain.push(...prevChain);
          }
        } catch (error) {
          console.log(`   âš ï¸  Could not load ${prevImplClassName}: ${error.message}`);
        }
      }
    }
    
    chain.push({
      status: targetStatus,
      className: ImplicationClass.name,
      actionName: meta.setup?.[0]?.actionName || 'unknown',
      testFile: meta.setup?.[0]?.testFile || 'unknown',
      platform: meta.platform || 'unknown',
      complete: currentStatus === targetStatus,
      isCurrent: currentStatus === targetStatus,
      isTarget: true
    });
    
    return chain;
  }
  
  findImplicationFile(className) {
    const searchPaths = [
      path.join(process.cwd(), 'tests/implications'),
      path.join(process.cwd(), 'tests/ai-testing/implications'),
      path.join(__dirname, '..')
    ];
    
    for (const basePath of searchPaths) {
      const filePath = path.join(basePath, `${className}.js`);
      if (fs.existsSync(filePath)) {
        return filePath;
      }
      
      if (fs.existsSync(basePath)) {
        const files = this.findFilesRecursive(basePath, `${className}.js`);
        if (files.length > 0) {
          return files[0];
        }
      }
    }
    
    return null;
  }
  
  findFilesRecursive(dir, filename) {
    const results = [];
    
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const item of items) {
        const fullPath = path.join(dir, item.name);
        
        if (item.isDirectory()) {
          results.push(...this.findFilesRecursive(fullPath, filename));
        } else if (item.name === filename) {
          results.push(fullPath);
        }
      }
    } catch (error) {
      // Skip directories we can't read
    }
    
    return results;
  }
  
  isReady(chain, currentStatus) {
    const incompleteSteps = chain.filter(step => !step.complete);
    
    if (incompleteSteps.length === 0) {
      return true;
    }
    
    if (incompleteSteps.length === 1 && incompleteSteps[0].isTarget) {
      return true;
    }
    
    return false;
  }
  
  findNextStep(chain, currentStatus) {
    const nextStep = chain.find(step => !step.complete && !step.isTarget);
    
    if (nextStep) {
      return {
        ...nextStep,
        executable: true
      };
    }
    
    return null;
  }
  
  /**
   * âœ… ENHANCED: Find missing fields with blocking support
   * 
   * Supports:
   * - Negation: !dancer.blocked_clubs
   * - Array containment: { contains: 'ctx.data.club.name' }
   * - Value resolution: ctx.data.club.name â†’ testData.club.name
   * - Simple equality: dancer.status: 'logged_in'
   */
  findMissingFields(meta, testData) {
    const missing = [];
    
    if (meta.requires) {
      for (const [field, requiredValue] of Object.entries(meta.requires)) {
        if (field === 'previousStatus') continue;
        
        // Handle negation: '!dancer.blocked_clubs' -> 'dancer.blocked_clubs'
        const isNegated = field.startsWith('!');
        const cleanField = isNegated ? field.slice(1) : field;
        
        // Get actual value (nested path support)
        const actualValue = cleanField.includes('.') 
          ? cleanField.split('.').reduce((obj, key) => obj?.[key], testData)
          : testData[cleanField];
        
        // Check if it's an array containment check: { contains: 'value' }
        if (typeof requiredValue === 'object' && requiredValue.contains) {
          // Resolve reference like 'ctx.data.club.name' to actual value
          const valueToCheck = this._resolveValue(requiredValue.contains, testData);
          
          // Check if array contains the value
          const arrayContains = Array.isArray(actualValue) && actualValue.includes(valueToCheck);
          
          // Fail if:
          // - Negated (should NOT contain) but it DOES contain
          // - Not negated (should contain) but it DOESN'T contain
          if ((isNegated && arrayContains) || (!isNegated && !arrayContains)) {
            missing.push({
              field: cleanField,
              required: isNegated 
                ? `NOT contain "${valueToCheck}"` 
                : `contain "${valueToCheck}"`,
              actual: actualValue
            });
          }
        }
        // Simple equality check
        else {
          const matches = actualValue === requiredValue;
          
          // Fail if:
          // - Negated (should NOT equal) but it DOES equal
          // - Not negated (should equal) but it DOESN'T equal
          if ((isNegated && matches) || (!isNegated && !matches)) {
            missing.push({
              field: cleanField,
              required: isNegated ? `NOT "${requiredValue}"` : requiredValue,
              actual: actualValue
            });
          }
        }
      }
    }
    
    if (meta.requiredFields && meta.requiredFields.length > 0) {
      for (const field of meta.requiredFields) {
        if (!testData.hasOwnProperty(field) || testData[field] === null || testData[field] === undefined) {
          missing.push({ field, required: 'defined', actual: 'missing' });
        }
      }
    }
    
    return missing;
  }
  
  /**
   * âœ… NEW: Resolve value references like 'ctx.data.club.name' to actual value
   * @param {string} path - Path to resolve (e.g., 'ctx.data.club.name' or 'club.name')
   * @param {object} testData - Test data object
   * @returns {*} Resolved value
   */
  _resolveValue(path, testData) {
    // Remove 'ctx.data.' prefix if present
    if (path.startsWith('ctx.data.')) {
      path = path.replace('ctx.data.', '');
    }
    
    // Navigate nested path: 'club.name' -> testData.club.name
    return path.split('.').reduce((obj, key) => obj?.[key], testData);
  }
  
  printNotReadyError(analysis) {
    const { currentStatus, targetStatus, chain, nextStep, missingFields } = analysis;
    
    console.error('\n' + 'â•'.repeat(60));
    console.error('âŒ TEST NOT READY - PREREQUISITES NOT MET');
    console.error('â•'.repeat(60));
    
    console.error(`\nğŸ“Š Status:`);
    console.error(`   Current: ${currentStatus}`);
    console.error(`   Target:  ${targetStatus}`);
    
    if (missingFields.length > 0) {
      console.error(`\nâŒ Missing Requirements:`);
      missingFields.forEach(fieldInfo => {
        if (typeof fieldInfo === 'string') {
          console.error(`   - ${fieldInfo}`);
        } else {
          console.error(`   - ${fieldInfo.field}: required=${fieldInfo.required}, actual=${fieldInfo.actual}`);
        }
      });
    }
    
    console.error(`\nğŸ—ºï¸  Full Path to Target:\n`);
    
    chain.forEach((step, index) => {
      const icon = step.complete ? 'âœ…' : step.isTarget ? 'ğŸ¯' : 'ğŸ“';
      const label = step.complete ? ' â† You are here' : step.isTarget ? ' â† Target' : '';
      
      console.error(`   ${icon} ${index + 1}. ${step.status}${label}`);
      
      if (!step.complete && !step.isTarget) {
        console.error(`      Action: ${step.actionName}`);
        console.error(`      Test: ${step.testFile}`);
      }
      
      if (index < chain.length - 1) {
        console.error('      â†“');
      }
    });
    
    if (nextStep) {
      console.error(`\nğŸ’¡ NEXT STEP: ${nextStep.status}`);
      console.error(`   Action: ${nextStep.actionName}`);
      console.error(`   Test: ${nextStep.testFile}`);
    }
    
    console.error('â•'.repeat(60) + '\n');
  }
  
  /**
   * âœ… RECURSIVE checkOrThrow - The magic happens here
   */
  static async checkOrThrow(ImplicationClass, testData, options = {}) {
    const planner = new TestPlanner({ 
      verbose: options.verbose ?? true,
      config: options.config
    });
    
    const analysis = planner.analyze(ImplicationClass, testData, options);
    
    const targetStatus = ImplicationClass.xstateConfig?.meta?.status;
    const currentStatus = testData.status;
    
    if (targetStatus && currentStatus === targetStatus) {
      console.log(`âœ… Already in target state (${targetStatus}), no action needed\n`);
      return { ready: true, skipped: true, currentStatus, targetStatus };
    }
    
    if (!analysis.ready && analysis.nextStep && options.page) {
      const { testFile, actionName } = analysis.nextStep;
      
      console.log(`\nâš¡ Auto-executing prerequisite: ${actionName}\n`);
      
      try {
        process.env.SKIP_UNIT_TEST_REGISTRATION = 'true';
        
        const testPath = path.join(
          process.cwd(), 
          'tests/implications',
          testFile
        );
        
        const testModule = require(testPath);
        delete process.env.SKIP_UNIT_TEST_REGISTRATION;
        
        const triggerFn = testModule[actionName];
        
        if (!triggerFn) {
          throw new Error(`Function ${actionName} not exported from ${testFile}`);
        }
        
        const testDataPath = options.testDataPath 
          || testData.__testDataPath 
          || process.env.TEST_DATA_PATH 
          || 'tests/data/shared.json';
        
        const result = await triggerFn(testDataPath, {
          page: options.page,
          testDataPath
        });
        
        if (result && result.save) {
          result.save(testDataPath);
          console.log('   ğŸ’¾ Prerequisite state saved');
        }
        
        const TestContext = require('./TestContext');
        const reloadedCtx = TestContext.load(ImplicationClass, testDataPath);
        Object.assign(testData, reloadedCtx.data);
        
        const newAnalysis = planner.analyze(ImplicationClass, reloadedCtx.data);
        
        if (!newAnalysis.ready) {
          // âœ… RECURSIVE CALL - Go deeper for multi-level chains
          return TestPlanner.checkOrThrow(ImplicationClass, reloadedCtx.data, options);
        }
        
        console.log('âœ… Prerequisites satisfied!\n');
        return newAnalysis;
        
      } catch (error) {
        console.error(`âŒ Failed to auto-execute prerequisite: ${error.message}\n`);
        delete process.env.SKIP_UNIT_TEST_REGISTRATION;
        planner.printNotReadyError(analysis);
        throw error;
      }
    }
    
    if (!analysis.ready) {
      planner.printNotReadyError(analysis);
      throw new Error('Prerequisites not met');
    }
    
    return analysis;
  }
}

module.exports = TestPlanner;
