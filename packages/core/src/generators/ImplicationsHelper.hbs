// Auto-generated by Implications Framework
// Location: {{outputPath}}
// Generated at: {{timestamp}}

/**
 * ImplicationsHelper
 * 
 * Provides utility functions for working with Implications, particularly
 * for merging base class configurations with state-specific overrides.
 * 
 * This enables DRY base classes that define common UI elements, with
 * child classes specifying only what changes in each state.
 */
class ImplicationsHelper {
  
  /**
   * Merges base screen config with status-specific overrides
   * 
   * Base classes use semantic categories:
   * - alwaysVisible: Elements ALWAYS present
   * - sometimesVisible: Elements that MIGHT be present (visible by default)
   * - hidden: Elements explicitly hidden
   * 
   * Child classes use state-specific categories:
   * - visible: Additional elements to show
   * - hidden: Elements to hide (overrides sometimesVisible)
   * 
   * @param {Object} baseConfig - Base configuration from BaseImplications
   * @param {Object} statusConfig - Status-specific overrides
   * @param {Object} options - Options
   * @param {boolean} options.appendPrerequisites - Append base prerequisites
   * @param {Object} options.parentClass - Optional parent class reference
   * @returns {Object} Merged configuration with checks
   * 
   * @example
   * // Base defines common elements
   * static web = {
   *   bookingCalendar: {
   *     alwaysVisible: ['calendar', 'header'],
   *     sometimesVisible: ['btnCreate'],
   *     hidden: ['btnCancel']
   *   }
   * }
   * 
   * // Child overrides for specific state
   * ImplicationsHelper.mergeWithBase(
   *   BaseBookingImplications.web.bookingCalendar,
   *   {
   *     description: "After creating booking",
   *     hidden: ['btnCreate']  // Hide the create button
   *   }
   * )
   * 
   * // Result:
   * {
   *   checks: {
   *     visible: ['calendar', 'header'],  // From alwaysVisible
   *     hidden: ['btnCancel', 'btnCreate']  // Base + child
   *   }
   * }
   */
  static mergeWithBase(baseConfig, statusConfig, options = {}) {
    const {
      appendPrerequisites = false,
      parentClass = null
    } = options;
    
    // Handle prerequisites
    let prerequisites;
    if (statusConfig.prerequisites) {
      if (appendPrerequisites) {
        const basePrereqs = baseConfig.prerequisites || [];
        prerequisites = [...basePrereqs, ...statusConfig.prerequisites];
      } else {
        prerequisites = statusConfig.prerequisites;
      }
    } else {
      prerequisites = baseConfig.prerequisites;
    }
    
    // Handle screen
    const screen = statusConfig.screen || baseConfig.screen;
    
    // Handle checks with smart merging
    const checks = {};
    
    // Text: statusConfig OVERRIDES base (field by field)
    if (statusConfig.text || baseConfig.defaultText) {
      checks.text = {
        ...(baseConfig.defaultText || {}),
        ...(statusConfig.text || {})
      };
    }
    
    // ✅ VISIBILITY LOGIC (aligned with frontend):
    const alwaysVisible = baseConfig.alwaysVisible || [];
    const sometimesVisible = baseConfig.sometimesVisible || [];  // ← Visible by default!
    const baseVisible = baseConfig.visible || [];
    const baseHidden = baseConfig.hidden || [];
    const statusVisible = statusConfig.visible || [];
    const statusHidden = statusConfig.hidden || [];
    
    // Final visible = alwaysVisible + sometimesVisible + baseVisible + statusVisible
    // (Child can override by putting sometimesVisible items in statusHidden)
    let finalVisible = [
      ...alwaysVisible,
      ...sometimesVisible,  // ← Include by default!
      ...baseVisible,
      ...statusVisible
    ];
    
    // Final hidden = baseHidden + statusHidden
    const finalHidden = [
      ...baseHidden,
      ...statusHidden
    ];
    
    // ✅ Remove conflicts: If item is in finalHidden, remove from finalVisible
    finalVisible = finalVisible.filter(item => !finalHidden.includes(item));
    
    // Only add arrays if they have content
    if (finalVisible.length > 0) {
      checks.visible = [...new Set(finalVisible)];  // Deduplicate
    }
    
    if (finalHidden.length > 0) {
      checks.hidden = [...new Set(finalHidden)];  // Deduplicate
    }
    
    // Merge other checks
    if (statusConfig.checks) {
      Object.assign(checks, statusConfig.checks);
    }
    
    // Return merged object
    return {
      screen,
      description: statusConfig.description || baseConfig.description,
      ...(prerequisites && { prerequisites }),
      checks,
      ...(statusConfig.expect && { expect: statusConfig.expect })
    };
  }
}

module.exports = ImplicationsHelper;