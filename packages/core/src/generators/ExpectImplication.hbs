// Auto-generated by Implications Framework
// Location: {{outputPath}}
{{#if timestamp}}// Generated: {{timestamp}}{{/if}}

const { expect } = require('@playwright/test');

/**
 * ExpectImplication - Validates UI state against implications
 * 
 * This class handles:
 * - Validating visible elements
 * - Validating hidden elements  
 * - Checking text content with variable substitution
 * - Running custom expect functions
 * - Supporting both Playwright and Appium
 */
class ExpectImplication {
  static async validateImplications(screenDef, testData, screenObject) {
    if (!screenDef || screenDef.length === 0) {
      console.log('   âš ï¸  No screen definition to validate');
      return;
    }
    
    const def = Array.isArray(screenDef) ? screenDef[0] : screenDef;
    
    console.log(`   ðŸ” Validating screen: ${def.name || 'unnamed'}`);
    
    // âœ… Get page from screen object
    const page = screenObject.page || screenObject;
    
    // Helper to get element from screen object
    const getElement = async (elementName) => {
      // âœ… First try to get from screen object properties
      if (screenObject[elementName]) {
        return screenObject[elementName];
      }
      
      // âœ… Fallback to page.locator if not found
      return page.locator(`[data-testid="${elementName}"]`);
    };
    
    // Execute prerequisites FIRST
    if (def.prerequisites && def.prerequisites.length > 0) {
      console.log(`   ðŸ”§ Running ${def.prerequisites.length} prerequisites...`);
      for (const prereq of def.prerequisites) {
        console.log(`      ${prereq.description}`);
        await prereq.setup(testData, page);
      }
      console.log('   âœ… Prerequisites completed');
    }
    
    // Validate visible elements
    if (def.visible && def.visible.length > 0) {
      console.log(`   âœ… Checking ${def.visible.length} visible elements...`);
      for (const elementName of def.visible) {
        try {
          const element = await getElement(elementName);
          await expect(element).toBeVisible({ timeout: 10000 });
          console.log(`      âœ“ ${elementName} is visible`);
        } catch (error) {
          console.error(`      âœ— ${elementName} NOT visible: ${error.message}`);
          throw new Error(`Visibility check failed for ${elementName}`);
        }
      }
    }
    
    // Validate hidden elements
    if (def.hidden && def.hidden.length > 0) {
      console.log(`   âœ… Checking ${def.hidden.length} hidden elements...`);
      for (const elementName of def.hidden) {
        try {
          const element = await getElement(elementName);
          const count = await element.count();
          
          if (count === 0) {
            console.log(`      âœ“ ${elementName} doesn't exist (counts as hidden)`);
            continue;
          }
          
          await expect(element).not.toBeVisible();
          console.log(`      âœ“ ${elementName} is hidden`);
        } catch (error) {
          console.error(`      âœ— ${elementName} NOT hidden: ${error.message}`);
          throw new Error(`Hidden check failed for ${elementName}`);
        }
      }
    }
    
    // Additional checks
    if (def.checks) {
      console.log('   ðŸ” Running additional checks...');
      
      if (def.checks.visible && def.checks.visible.length > 0) {
        console.log(`   âœ… Checking ${def.checks.visible.length} additional visible elements...`);
        for (const elementName of def.checks.visible) {
          try {
            const element = await getElement(elementName);
            await expect(element).toBeVisible({ timeout: 10000 });
            console.log(`      âœ“ ${elementName} is visible`);
          } catch (error) {
            console.error(`      âœ— ${elementName} NOT visible: ${error.message}`);
            throw new Error(`Checks.visible failed for ${elementName}`);
          }
        }
      }
      
      if (def.checks.hidden && def.checks.hidden.length > 0) {
        console.log(`   âœ… Checking ${def.checks.hidden.length} additional hidden elements...`);
        for (const elementName of def.checks.hidden) {
          try {
            const element = await getElement(elementName);
            const count = await element.count();
            
            if (count === 0) {
              console.log(`      âœ“ ${elementName} doesn't exist (counts as hidden)`);
              continue;
            }
            
            await expect(element).not.toBeVisible();
            console.log(`      âœ“ ${elementName} is hidden`);
          } catch (error) {
            console.error(`      âœ— ${elementName} NOT hidden: ${error.message}`);
            throw new Error(`Checks.hidden failed for ${elementName}`);
          }
        }
      }
      
      if (def.checks.text && Object.keys(def.checks.text).length > 0) {
        console.log(`   âœ… Checking ${Object.keys(def.checks.text).length} text checks...`);
        for (const [elementName, expectedText] of Object.entries(def.checks.text)) {
          try {
            const element = await getElement(elementName);
            
            let finalText = expectedText;
            if (typeof expectedText === 'string' && expectedText.includes('{{')) {
              const variableMatch = expectedText.match(/\{\{(\w+)\}\}/);
              if (variableMatch && testData && testData[variableMatch[1]]) {
                finalText = expectedText.replace(/\{\{(\w+)\}\}/, testData[variableMatch[1]]);
                console.log(`      ðŸ“ Substituted {{${variableMatch[1]}}} -> ${testData[variableMatch[1]]}`);
              }
            }
            
            await expect(element).toHaveText(finalText, { timeout: 10000 });
            console.log(`      âœ“ ${elementName} has text: "${finalText}"`);
          } catch (error) {
            console.error(`      âœ— ${elementName} text check failed: ${error.message}`);
            throw new Error(`Text check failed for ${elementName}`);
          }
        }
      }
    }
    
    // Custom expect function
    if (def.expect && typeof def.expect === 'function') {
      console.log('   ðŸŽ¯ Running custom expect function...');
      await def.expect(testData, page);
      console.log('   âœ… Custom expect passed');
    }
    
    console.log(`   âœ… All validations passed for ${def.name || 'screen'}`);
  }
  
  static isPlaywright(element) {
    return element && typeof element.locator === 'function';
  }
}

module.exports = ExpectImplication;
