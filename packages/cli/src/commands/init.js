import inquirer from 'inquirer';
import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { logger } from '../utils/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Analyze project structure
 */
function analyzeProject(projectPath) {
  const analysis = {
    projectName: path.basename(projectPath),
    domain: 'general',
    testRunner: 'playwright',
    testsPath: 'tests',
    testDataMode: 'stateless',
    platforms: ['web'],
    patterns: {
      screenObjects: [],
      sections: []
    }
  };
  
  // Detect test runner
  const pkgPath = path.join(projectPath, 'package.json');
  if (fs.existsSync(pkgPath)) {
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
    const deps = { ...pkg.dependencies, ...pkg.devDependencies };
    
    if (deps['@playwright/test']) {
      analysis.testRunner = 'playwright';
    } else if (deps['cypress']) {
      analysis.testRunner = 'cypress';
    } else if (deps['webdriverio']) {
      analysis.testRunner = 'webdriverio';
    }
  }
  
  // Detect test directory
  const commonTestDirs = ['tests', 'test', '__tests__', 'e2e', 'specs'];
  for (const dir of commonTestDirs) {
    if (fs.existsSync(path.join(projectPath, dir))) {
      analysis.testsPath = dir;
      break;
    }
  }
  
  return analysis;
}

/**
 * Create necessary directories
 */
function createDirectories(projectPath, analysis) {
  const dirs = [
    path.join(projectPath, analysis.testsPath, 'implications'),
    path.join(projectPath, analysis.testsPath, 'implications', 'utils')
  ];
  
  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
  
  return dirs.map(d => path.relative(projectPath, d));
}

/**
 * Copy utility files
 */
async function copyUtilities(projectPath, analysis) {
  const utilsDir = path.join(projectPath, analysis.testsPath, 'implications', 'utils');
  
  // Find core package - navigate up from CLI to find packages/core
  const coreDir = path.join(__dirname, '../../../../core/src');
  
  console.log('üì¶ Looking for core package at:', coreDir);
  
  if (!fs.existsSync(coreDir)) {
    throw new Error(`Could not find core package at ${coreDir}`);
  }
  
  const files = [
    { src: 'TestContext.js', dest: 'TestContext.js' },
    { src: 'ExpectImplication.js', dest: 'ExpectImplication.js' }
  ];
  
  const copiedFiles = [];
  
  for (const { src, dest } of files) {
    const srcPath = path.join(coreDir, src);
    const destPath = path.join(utilsDir, dest);
    
    if (fs.existsSync(srcPath)) {
      await fs.copy(srcPath, destPath);
      copiedFiles.push(path.relative(projectPath, destPath));
      console.log(`‚úÖ Copied: ${src}`);
    } else {
      console.warn(`‚ö†Ô∏è  File not found: ${srcPath}`);
    }
  }
  
  return copiedFiles;
}

/**
 * Generate config file
 */
async function generateConfig(projectPath, analysis) {
  const configPath = path.join(projectPath, 'ai-testing.config.js');
  
  const config = `// ai-testing.config.js
// Generated by Implications Framework

module.exports = {
  // === Project Info ===
  projectName: "${analysis.projectName}",
  domain: '${analysis.domain}',
  
  // === Paths ===
  paths: {
    tests: '${analysis.testsPath}',
    implications: '${analysis.testsPath}/implications',
    utils: '${analysis.testsPath}/implications/utils',
    screenObjects: '${analysis.testsPath}/screenObjects'
  },
  
  // === Test Configuration ===
  testRunner: '${analysis.testRunner}',
  platforms: ${JSON.stringify(analysis.platforms)},
  
  // === Architecture ===
  testDataMode: '${analysis.testDataMode}', // 'stateless' or 'stateful'
  
  // === Patterns ===
  patterns: {
    screenObjects: [],
    sections: [],
    implications: [
      '${analysis.testsPath}/implications/**/*Implications.js'
    ],
    tests: [
      '${analysis.testsPath}/**/*.spec.js'
    ]
  }
};
`;
  
  await fs.writeFile(configPath, config);
  return 'ai-testing.config.js';
}

/**
 * Create README
 */
async function createReadme(projectPath, analysis) {
  const readmePath = path.join(
    projectPath, 
    analysis.testsPath, 
    'implications', 
    'README.md'
  );
  
  const readme = `# Implications Framework

This directory contains auto-generated implications-based tests.

## Structure

\`\`\`
${analysis.testsPath}/implications/
‚îú‚îÄ‚îÄ utils/                    # Utility files (auto-copied)
‚îÇ   ‚îú‚îÄ‚îÄ TestContext.js       # Data management
‚îÇ   ‚îî‚îÄ‚îÄ ExpectImplication.js # Validation engine
‚îÇ
‚îú‚îÄ‚îÄ [domain]/                # Your implications (to be generated)
‚îÇ   ‚îî‚îÄ‚îÄ [Type]Implications.js
‚îÇ
‚îî‚îÄ‚îÄ README.md                # This file
\`\`\`

## Next Steps

1. **Discover patterns:**
   \`\`\`bash
   implications discover
   \`\`\`

2. **Open web UI:**
   Open the Implications Framework web interface to visually create and edit implications.

## Documentation

For more information, visit the Implications Framework documentation.
`;
  
  await fs.writeFile(readmePath, readme);
  return path.relative(projectPath, readmePath);
}

export async function initCommand() {
  const projectPath = process.cwd();
  
  console.log(chalk.blue.bold('\nüéØ Initializing Implications Framework...\n'));
  
  try {
    // Step 1: Analyze project
    const spinner1 = ora('Analyzing project structure...').start();
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const analysis = analyzeProject(projectPath);
    spinner1.succeed(chalk.green('Project analyzed'));
    
    console.log(chalk.gray('   Test framework:'), chalk.white(analysis.testRunner));
    console.log(chalk.gray('   Test directory:'), chalk.white(analysis.testsPath));
    console.log(chalk.gray('   Architecture:'), chalk.white(analysis.testDataMode));
    
    // Step 2: Check if already initialized
    const configPath = path.join(projectPath, 'ai-testing.config.js');
    if (fs.existsSync(configPath)) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  Project already initialized'));
      console.log(chalk.gray('   Config file exists at:'), chalk.white(configPath));
      
      const { overwrite } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'overwrite',
          message: 'Overwrite existing configuration?',
          default: false
        }
      ]);
      
      if (!overwrite) {
        console.log(chalk.gray('\nInitialization cancelled.'));
        return;
      }
    }
    
    // Step 3: Create directories
    const spinner2 = ora('Creating directories...').start();
    const dirs = createDirectories(projectPath, analysis);
    spinner2.succeed(chalk.green(`Created ${dirs.length} directories`));
    
    // Step 4: Copy utility files
    const spinner3 = ora('Copying utility files...').start();
    const utilFiles = await copyUtilities(projectPath, analysis);
    spinner3.succeed(chalk.green(`Copied ${utilFiles.length} utility files`));
    
    utilFiles.forEach(file => {
      console.log(chalk.gray('   ‚úÖ'), chalk.white(file));
    });
    
    // Step 5: Generate config
    const spinner4 = ora('Generating configuration...').start();
    const configFile = await generateConfig(projectPath, analysis);
    spinner4.succeed(chalk.green('Configuration created'));
    console.log(chalk.gray('   ‚úÖ'), chalk.white(configFile));
    
    // Step 6: Create README
    const spinner5 = ora('Creating documentation...').start();
    const readmeFile = await createReadme(projectPath, analysis);
    spinner5.succeed(chalk.green('Documentation created'));
    console.log(chalk.gray('   ‚úÖ'), chalk.white(readmeFile));
    
    // Success!
    console.log(chalk.green.bold('\nüéâ Setup complete!\n'));
    console.log(chalk.blue('Next steps:'));
    console.log(chalk.gray('   1. Review'), chalk.white('ai-testing.config.js'));
    console.log(chalk.gray('   2. Open the web UI to create implications'));
    console.log(chalk.gray('   3. Start building your tests!\n'));
    
  } catch (error) {
    console.error(chalk.red('\n‚ùå Initialization failed:'), error.message);
    if (process.env.DEBUG) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}